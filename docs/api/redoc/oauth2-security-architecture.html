<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>API Overview ‚Äì SmartSupplyPro</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="SmartSupplyPro API documentation hub with comprehensive endpoint guides, security architecture, and integration resources." />
  <link rel="icon" href="https://keglev.github.io/inventory-service/favicon.ico" />
  <style>
    body { margin: 0; font-family: system-ui, sans-serif; background: #fafafa; color: #111; }
    header { background-color: #0d1117; color: white; padding: 1rem 2rem;
             display: flex; justify-content: space-between; align-items: center; }
    nav { background: #f3f4f6; padding: 1rem 2rem; }
    nav a { margin-right: 1.5rem; text-decoration: none; font-weight: 500; color: #0366d6; }
    nav a:hover { text-decoration: underline; }
    main { max-width: 900px; margin: 2rem auto; padding: 0 2rem; line-height: 1.6; }
    main h1, main h2, main h3 { color: #0d1117; }
    pre, code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
                "Liberation Mono", "Courier New", monospace; background: #f6f8fa;
                border-radius: 6px; padding: 0.2rem 0.4rem; }
    pre { padding: 1rem; overflow: auto; }
    footer { text-align: center; padding: 2rem; font-size: 0.875rem; color: #666; }
  </style>
</head>
<body>
  <header>
    <h1>API Index HUB</h1>
    <a href="https://github.com/Keglev/inventory-service" target="_blank" style="color: #58a6ff;">View on GitHub ‚Üó</a>
  </header>
  <nav>
    <a href="https://keglev.github.io/inventory-service/">üè† Home</a>
  <a href="https://keglev.github.io/inventory-service/api/redoc/api.html">üìò API Reference</a>
  </nav>
  <main>
    <h1>OAuth2 Security Architecture</h1>
<h2>Architecture Overview</h2>
<p>The SmartSupplyPro OAuth2 security architecture implements enterprise-grade authentication using Google OAuth2 with stateless authorization request management and automatic user provisioning. This architecture is designed for high availability, horizontal scalability, and secure cross-origin authentication flows.</p>
<h2>System Architecture Diagram</h2>
<pre><code class="language-mermaid">graph TB
    subgraph &quot;Frontend (React/Vite)&quot;
        FE[Frontend Application]
        FE_AUTH[Authentication Flow]
        FE_REDIRECT[Return Redirect]
    end
    
    subgraph &quot;Backend (Spring Security)&quot;
        subgraph &quot;Security Layer&quot;
            OAUTH_CONFIG[OAuth2 Configuration]
            AUTH_HANDLER[OAuth2LoginSuccessHandler]
            COOKIE_REPO[CookieOAuth2AuthorizationRequestRepository]
            CUSTOM_USER[CustomOAuth2UserService]
        end
        
        subgraph &quot;Security Components&quot;
            SEC_CONFIG[SecurityConfig]
            JWT_UTIL[JWT Utilities]
            USER_DETAILS[UserDetailsService]
        end
    end
    
    subgraph &quot;External Services&quot;
        GOOGLE[Google OAuth2 Provider]
        OAUTH_ENDPOINTS[OAuth2 Endpoints]
    end
    
    subgraph &quot;Data Layer&quot;
        USER_REPO[UserRepository]
        DB[(Database)]
    end
    
    subgraph &quot;Infrastructure&quot;
        LB[Load Balancer]
        SSL[SSL Termination]
    end
    
    %% Authentication Flow
    FE --&gt;|1. Initiate OAuth2| OAUTH_CONFIG
    OAUTH_CONFIG --&gt;|2. Save Auth Request| COOKIE_REPO
    COOKIE_REPO --&gt;|3. Set Secure Cookie| FE
    FE --&gt;|4. Redirect to Google| GOOGLE
    GOOGLE --&gt;|5. OAuth2 Callback| AUTH_HANDLER
    AUTH_HANDLER --&gt;|6. Load Auth Request| COOKIE_REPO
    AUTH_HANDLER --&gt;|7. User Provisioning| CUSTOM_USER
    CUSTOM_USER --&gt;|8. Create/Load User| USER_REPO
    USER_REPO --&gt;|9. User Data| DB
    AUTH_HANDLER --&gt;|10. Success Redirect| FE_REDIRECT
    
    %% Infrastructure
    LB --&gt;|HTTPS Termination| SSL
    SSL --&gt;|X-Forwarded-Proto| OAUTH_CONFIG
    
    style OAUTH_CONFIG fill:#e1f5fe
    style AUTH_HANDLER fill:#e8f5e8
    style COOKIE_REPO fill:#fff3e0
    style CUSTOM_USER fill:#f3e5f5
</code></pre>
<h2>Core Security Components</h2>
<h3>1. OAuth2 Configuration Architecture</h3>
<h4>Spring Security OAuth2 Configuration</h4>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            .oauth2Login(oauth -&gt; oauth
                .authorizationEndpoint(ae -&gt; ae
                    .authorizationRequestRepository(cookieOAuth2AuthorizationRequestRepository)
                )
                .userInfoEndpoint(ui -&gt; ui
                    .oidcUserService(customOidcUserService)
                    .userService(customOAuth2UserService)
                )
                .successHandler(oAuth2LoginSuccessHandler)
                .failureHandler(oauthFailureHandler(securityProperties))
            )
            .build();
    }
}
</code></pre>
<h4>OAuth2 Provider Configuration</h4>
<pre><code class="language-yaml">spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: ${GOOGLE_CLIENT_ID}
            client-secret: ${GOOGLE_CLIENT_SECRET}
            scope: openid,profile,email
            redirect-uri: &quot;{baseUrl}/login/oauth2/code/{registrationId}&quot;
        provider:
          google:
            authorization-uri: https://accounts.google.com/o/oauth2/v2/auth
            token-uri: https://oauth2.googleapis.com/token
            user-info-uri: https://www.googleapis.com/oauth2/v3/userinfo
            jwk-set-uri: https://www.googleapis.com/oauth2/v3/certs
</code></pre>
<h3>2. Stateless Authorization Request Management</h3>
<h4>Cookie-Based State Persistence</h4>
<pre><code class="language-mermaid">sequenceDiagram
    participant FE as Frontend
    participant BE as Backend
    participant COOKIE as Cookie Repository
    participant GOOGLE as Google OAuth2
    
    FE-&gt;&gt;BE: 1. Initiate OAuth2 Login
    BE-&gt;&gt;COOKIE: 2. Create Authorization Request
    COOKIE-&gt;&gt;COOKIE: 3. Serialize to JSON + Base64
    COOKIE-&gt;&gt;FE: 4. Set Secure Cookie (OAUTH2_AUTH_REQUEST)
    BE-&gt;&gt;GOOGLE: 5. Redirect to Google
    
    GOOGLE-&gt;&gt;FE: 6. User Authentication
    GOOGLE-&gt;&gt;BE: 7. OAuth2 Callback
    BE-&gt;&gt;COOKIE: 8. Load Authorization Request
    COOKIE-&gt;&gt;COOKIE: 9. Deserialize from Cookie
    COOKIE-&gt;&gt;BE: 10. Return Auth Request
    COOKIE-&gt;&gt;FE: 11. Delete Cookie (Cleanup)
    
    Note over COOKIE: Stateless Design
    Note over COOKIE: No Server Memory
    Note over COOKIE: Load Balancer Friendly
</code></pre>
<h4>Cookie Security Attributes</h4>
<pre><code class="language-java">// Enterprise Cookie Security Configuration
Cookie authRequestCookie = new Cookie(AUTH_REQUEST_COOKIE_NAME, encodedValue);
authRequestCookie.setHttpOnly(true);          // XSS Protection
authRequestCookie.setSecure(isHttpsRequest);   // HTTPS Enforcement
authRequestCookie.setPath(&quot;/&quot;);                // Application-wide scope
authRequestCookie.setMaxAge(180);              // 3-minute expiration
// SameSite=None for cross-origin flows (set via header)
</code></pre>
<h3>3. User Provisioning Architecture</h3>
<h4>Automatic User Creation Flow</h4>
<pre><code class="language-mermaid">graph TD
    A[OAuth2 Success] --&gt; B{User Exists?}
    B --&gt;|Yes| C[Load Existing User]
    B --&gt;|No| D[Create New User]
    D --&gt; E[Set Default Role: USER]
    D --&gt; F[Set Creation Timestamp]
    D --&gt; G{Concurrent Creation?}
    G --&gt;|Conflict| H[Handle Race Condition]
    G --&gt;|Success| I[User Provisioned]
    H --&gt; J[Load Existing User]
    C --&gt; I
    J --&gt; I
    I --&gt; K[Authentication Complete]
    
    style D fill:#e8f5e8
    style G fill:#fff3e0
    style H fill:#ffebee
</code></pre>
<h4>User Entity Structure</h4>
<pre><code class="language-java">@Entity
@Table(name = &quot;users&quot;)
public class AppUser {
    @Id
    @Column(unique = true, nullable = false)
    private String email;           // OAuth2 email as primary identifier
    
    @Column(nullable = false)
    private String name;            // Display name from OAuth2 provider
    
    @Enumerated(EnumType.STRING)
    private Role role = Role.USER;  // Default role for OAuth2 users
    
    private LocalDateTime createdAt; // Audit trail for user creation
    private LocalDateTime lastLoginAt; // Track user activity
}
</code></pre>
<h3>4. Cross-Origin Authentication Flow</h3>
<h4>Frontend-Backend Integration</h4>
<pre><code class="language-mermaid">sequenceDiagram
    participant SPA as React SPA
    participant API as Spring API
    participant GOOGLE as Google OAuth2
    participant COOKIE as Cookie Storage
    
    Note over SPA,COOKIE: Cross-Origin Authentication
    
    SPA-&gt;&gt;API: 1. Login Request (/oauth2/authorization/google?return=frontend_url)
    API-&gt;&gt;COOKIE: 2. Store Authorization Request
    COOKIE-&gt;&gt;SPA: 3. Set Secure Cookie (SameSite=None)
    API-&gt;&gt;GOOGLE: 4. Redirect to Google OAuth2
    
    GOOGLE-&gt;&gt;SPA: 5. User Authentication UI
    SPA-&gt;&gt;GOOGLE: 6. User Credentials
    GOOGLE-&gt;&gt;API: 7. OAuth2 Callback (/login/oauth2/code/google)
    
    API-&gt;&gt;COOKIE: 8. Retrieve Authorization Request
    API-&gt;&gt;API: 9. User Provisioning
    API-&gt;&gt;COOKIE: 10. Set Return URL Cookie
    API-&gt;&gt;SPA: 11. Redirect to Frontend
    
    SPA-&gt;&gt;COOKIE: 12. Read Return URL
    SPA-&gt;&gt;SPA: 13. Navigate to Protected Route
    
    Note over SPA,API: Authenticated Session
</code></pre>
<h4>Return URL Security</h4>
<pre><code class="language-java">// Enterprise Return URL Validation
private static final List&lt;String&gt; ALLOWED_ORIGINS = List.of(
    &quot;http://localhost:5173&quot;,                    // Development
    &quot;https://localhost:5173&quot;,                   // Development HTTPS
    &quot;https://inventory-service.koyeb.app&quot;       // Production
);

// Origin allowlist prevents open redirect attacks
if (returnUrl != null &amp;&amp; ALLOWED_ORIGINS.contains(returnUrl)) {
    Cookie returnCookie = new Cookie(&quot;SSP_RETURN&quot;, returnUrl);
    returnCookie.setHttpOnly(false);  // Frontend needs read access
    returnCookie.setSecure(isHttpsRequest);
    returnCookie.setPath(&quot;/&quot;);
    returnCookie.setMaxAge(300);      // 5-minute expiration
    addCookieWithSameSite(response, returnCookie, &quot;None&quot;);
}
</code></pre>
<h2>Security Implementation Layers</h2>
<h3>1. Transport Security Layer</h3>
<h4>HTTPS Enforcement</h4>
<pre><code class="language-java">// Enterprise HTTPS Detection
private static boolean isSecureOrForwardedHttps(HttpServletRequest request) {
    // Direct HTTPS detection
    if (request.isSecure()) return true;
    
    // Load balancer HTTPS detection
    String xForwardedProto = request.getHeader(&quot;X-Forwarded-Proto&quot;);
    return xForwardedProto != null &amp;&amp; xForwardedProto.equalsIgnoreCase(&quot;https&quot;);
}
</code></pre>
<h4>Load Balancer Integration</h4>
<pre><code class="language-yaml"># Infrastructure Configuration
server:
  forward-headers-strategy: native  # X-Forwarded-* header support
  
# Cookie security with load balancer SSL termination
management:
  server:
    ssl:
      enabled: false  # SSL terminated at load balancer
</code></pre>
<h3>2. Cookie Security Layer</h3>
<h4>Cookie Security Matrix</h4>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Value</th>
<th>Purpose</th>
<th>Security Benefit</th>
</tr>
</thead>
<tbody><tr>
<td>HttpOnly</td>
<td>true</td>
<td>XSS Protection</td>
<td>Prevent JavaScript access</td>
</tr>
<tr>
<td>Secure</td>
<td>auto-detect</td>
<td>HTTPS Enforcement</td>
<td>Encrypted transport only</td>
</tr>
<tr>
<td>SameSite</td>
<td>None</td>
<td>Cross-Origin Support</td>
<td>Legitimate cross-site flows</td>
</tr>
<tr>
<td>MaxAge</td>
<td>180/300s</td>
<td>Timeout Protection</td>
<td>Limited exposure window</td>
</tr>
<tr>
<td>Path</td>
<td>/</td>
<td>Application Scope</td>
<td>Application-wide availability</td>
</tr>
</tbody></table>
<h4>SameSite Cookie Implementation</h4>
<pre><code class="language-java">// Enterprise Cross-Origin Cookie Support
private static void addCookieWithSameSite(HttpServletResponse response, 
                                         Cookie cookie, String sameSite) {
    StringBuilder cookieHeader = new StringBuilder();
    cookieHeader.append(cookie.getName()).append(&#39;=&#39;).append(cookie.getValue());
    cookieHeader.append(&quot;; Path=&quot;).append(cookie.getPath());
    
    if (cookie.getMaxAge() &gt;= 0) {
        cookieHeader.append(&quot;; Max-Age=&quot;).append(cookie.getMaxAge());
    }
    if (cookie.getSecure()) {
        cookieHeader.append(&quot;; Secure&quot;);
    }
    if (cookie.isHttpOnly()) {
        cookieHeader.append(&quot;; HttpOnly&quot;);
    }
    if (sameSite != null &amp;&amp; !sameSite.isBlank()) {
        cookieHeader.append(&quot;; SameSite=&quot;).append(sameSite);
    }
    
    response.addHeader(&quot;Set-Cookie&quot;, cookieHeader.toString());
}
</code></pre>
<h3>3. Application Security Layer</h3>
<h4>OAuth2 Custom User Services</h4>
<pre><code class="language-java">@Service
public class CustomOAuth2UserService implements OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; {
    
    @Override
    public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {
        // Load user from OAuth2 provider
        OAuth2User oauth2User = defaultService.loadUser(userRequest);
        
        // Extract user information
        String email = oauth2User.getAttribute(&quot;email&quot;);
        String name = oauth2User.getAttribute(&quot;name&quot;);
        
        // Provision user in local database
        AppUser user = userService.findOrCreateUser(email, name);
        
        // Return custom principal with local user information
        return new CustomOAuth2User(oauth2User, user);
    }
}
</code></pre>
<h4>OIDC User Service Integration</h4>
<pre><code class="language-java">@Service
public class CustomOidcUserService implements OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; {
    
    @Override
    public OidcUser loadUser(OidcUserRequest userRequest) throws OAuth2AuthenticationException {
        // Process OIDC ID token
        OidcUser oidcUser = defaultService.loadUser(userRequest);
        
        // Extract verified email from ID token
        String email = oidcUser.getEmail();
        String name = oidcUser.getFullName();
        
        // Provision user with OIDC claims
        AppUser user = userService.findOrCreateUser(email, name);
        
        return new CustomOidcUser(oidcUser, user);
    }
}
</code></pre>
<h2>Scalability and Performance Architecture</h2>
<h3>1. Horizontal Scaling Design</h3>
<h4>Stateless Session Management</h4>
<pre><code class="language-mermaid">graph TB
    subgraph &quot;Load Balancer&quot;
        LB[HTTPS Load Balancer]
    end
    
    subgraph &quot;Application Instances&quot;
        APP1[Instance 1]
        APP2[Instance 2]
        APP3[Instance 3]
    end
    
    subgraph &quot;Shared State&quot;
        DB[(User Database)]
        COOKIES[Client Cookies]
    end
    
    LB --&gt;|Round Robin| APP1
    LB --&gt;|Round Robin| APP2
    LB --&gt;|Round Robin| APP3
    
    APP1 --&gt;|User Data| DB
    APP2 --&gt;|User Data| DB
    APP3 --&gt;|User Data| DB
    
    APP1 -.-&gt;|OAuth2 State| COOKIES
    APP2 -.-&gt;|OAuth2 State| COOKIES
    APP3 -.-&gt;|OAuth2 State| COOKIES
    
    Note over COOKIES: No Session Affinity Required
    Note over DB: Shared User State
</code></pre>
<h4>Instance Independence Benefits</h4>
<ul>
<li><strong>OAuth2 Callbacks</strong>: Any instance can handle OAuth2 provider callbacks</li>
<li><strong>No Session Replication</strong>: Cookie-based state eliminates session synchronization</li>
<li><strong>Load Balancer Flexibility</strong>: No sticky sessions required</li>
<li><strong>Auto-Scaling</strong>: Instances can be added/removed without state migration</li>
</ul>
<h3>2. Performance Optimization</h3>
<h4>Cookie Serialization Optimization</h4>
<pre><code class="language-java">// Enterprise Serialization: Minimal JSON structure
private String writeJson(OAuth2AuthorizationRequest request) {
    Map&lt;String, Object&gt; minimalState = Map.of(
        &quot;authorizationUri&quot;, request.getAuthorizationUri(),
        &quot;clientId&quot;, request.getClientId(),
        &quot;redirectUri&quot;, request.getRedirectUri(),
        &quot;scopes&quot;, request.getScopes(),
        &quot;state&quot;, request.getState(),
        &quot;responseType&quot;, request.getResponseType().getValue(),
        &quot;additionalParameters&quot;, request.getAdditionalParameters(),
        &quot;attributes&quot;, request.getAttributes(),
        &quot;authorizationRequestUri&quot;, request.getAuthorizationRequestUri()
    );
    
    return objectMapper.writeValueAsString(minimalState);
}
</code></pre>
<h4>Database Optimization</h4>
<pre><code class="language-sql">-- User provisioning optimization
CREATE INDEX idx_users_email ON users(email);        -- Fast user lookup
CREATE INDEX idx_users_created_at ON users(created_at); -- Audit queries
CREATE INDEX idx_users_last_login ON users(last_login_at); -- Activity tracking

-- Constraint for concurrent user creation
ALTER TABLE users ADD CONSTRAINT uk_users_email UNIQUE (email);
</code></pre>
<h2>Error Handling and Resilience Architecture</h2>
<h3>1. OAuth2 Flow Error Handling</h3>
<h4>Graceful Degradation Strategy</h4>
<pre><code class="language-mermaid">graph TD
    A[OAuth2 Request] --&gt; B{Cookie Valid?}
    B --&gt;|Yes| C[Process Authentication]
    B --&gt;|No| D[Log Warning]
    D --&gt; E[Continue Without State]
    E --&gt; F[Fallback Authentication]
    
    C --&gt; G{User Creation Success?}
    G --&gt;|Yes| H[Authentication Complete]
    G --&gt;|Conflict| I[Handle Race Condition]
    I --&gt; J[Load Existing User]
    J --&gt; H
    
    F --&gt; K[Error Page/Retry]
    
    style D fill:#fff3e0
    style I fill:#ffebee
    style F fill:#e3f2fd
</code></pre>
<h4>Error Recovery Patterns</h4>
<pre><code class="language-java">// Enterprise Error Handling: Multi-layer resilience
public Optional&lt;OAuth2AuthorizationRequest&gt; loadAuthorizationRequest(HttpServletRequest request) {
    Cookie[] cookies = request.getCookies();
    if (cookies == null) return Optional.empty();
    
    // Search all cookies for valid authorization request
    for (Cookie cookie : cookies) {
        if (AUTH_REQUEST_COOKIE_NAME.equals(cookie.getName())) {
            try {
                // Attempt deserialization
                String json = new String(Base64.getUrlDecoder()
                    .decode(cookie.getValue()), StandardCharsets.UTF_8);
                OAuth2AuthorizationRequest request = readJson(json);
                if (request != null) {
                    return Optional.of(request);
                }
            } catch (Exception e) {
                // Enterprise Resilience: Log and continue search
                log.debug(&quot;Failed to deserialize authorization request cookie&quot;, e);
            }
        }
    }
    
    return Optional.empty();  // Graceful fallback
}
</code></pre>
<h3>2. Concurrent User Creation Handling</h3>
<h4>Race Condition Resolution</h4>
<pre><code class="language-java">// Enterprise Concurrency: Database constraint-based resolution
private AppUser createUserSafely(String email, String name) {
    try {
        AppUser newUser = new AppUser(email, name);
        newUser.setRole(Role.USER);
        newUser.setCreatedAt(LocalDateTime.now());
        return userRepository.save(newUser);
    } catch (DataIntegrityViolationException e) {
        // Handle concurrent creation attempt
        return userRepository.findByEmail(email)
            .orElseThrow(() -&gt; new IllegalStateException(
                &quot;User already exists but cannot be loaded: &quot; + email));
    }
}
</code></pre>
<h2>Security Monitoring and Audit Architecture</h2>
<h3>1. Security Event Logging</h3>
<h4>Audit Trail Structure</h4>
<pre><code class="language-java">// Enterprise Security Logging
@Component
public class SecurityAuditLogger {
    
    public void logAuthenticationSuccess(String email, String origin) {
        log.info(&quot;OAuth2 authentication success: user={}, origin={}&quot;, email, origin);
    }
    
    public void logUserProvisioning(String email, boolean isNewUser) {
        log.info(&quot;User provisioning: email={}, newUser={}&quot;, email, isNewUser);
    }
    
    public void logSecurityViolation(String event, String details) {
        log.warn(&quot;Security violation: event={}, details={}&quot;, event, details);
    }
    
    public void logReturnUrlViolation(String requestedUrl, String clientIp) {
        log.warn(&quot;Invalid return URL attempted: url={}, ip={}&quot;, requestedUrl, clientIp);
    }
}
</code></pre>
<h3>2. Security Metrics Collection</h3>
<h4>Monitoring Metrics</h4>
<pre><code class="language-yaml"># Security monitoring configuration
management:
  metrics:
    tags:
      service: inventory-service
      layer: security
  endpoints:
    web:
      exposure:
        include: health,metrics,info
        
# Custom security metrics
security:
  metrics:
    oauth2:
      success-rate: true      # Authentication success percentage
      user-provisioning: true # New user creation rate
      security-violations: true # Invalid requests
      cookie-errors: true     # State deserialization failures
</code></pre>
<h2>Production Deployment Architecture</h2>
<h3>1. Environment Configuration</h3>
<h4>Multi-Environment Security Setup</h4>
<pre><code class="language-yaml"># Development Environment
spring:
  profiles: dev
  security:
    oauth2:
      allowed-origins:
        - &quot;http://localhost:5173&quot;
        - &quot;https://localhost:5173&quot;
      cookie:
        secure: false  # Allow HTTP in development
        
# Production Environment  
spring:
  profiles: prod
  security:
    oauth2:
      allowed-origins:
        - &quot;https://inventory-service.koyeb.app&quot;
      cookie:
        secure: true   # Enforce HTTPS in production
</code></pre>
<h3>2. Infrastructure Integration</h3>
<h4>Container Deployment Configuration</h4>
<pre><code class="language-dockerfile"># Security-focused container configuration
FROM openjdk:17-jre-slim

# Security: Non-root user
RUN groupadd -r appuser &amp;&amp; useradd -r -g appuser appuser
USER appuser

# OAuth2 configuration via environment variables
ENV GOOGLE_CLIENT_ID=&quot;&quot;
ENV GOOGLE_CLIENT_SECRET=&quot;&quot;
ENV SPRING_PROFILES_ACTIVE=&quot;prod&quot;

# HTTPS enforcement
ENV SERVER_FORWARD_HEADERS_STRATEGY=&quot;native&quot;

EXPOSE 8080
</code></pre>
<h4>Load Balancer Configuration</h4>
<pre><code class="language-nginx"># NGINX load balancer with SSL termination
upstream backend {
    server app1:8080;
    server app2:8080;
    server app3:8080;
}

server {
    listen 443 ssl http2;
    server_name inventory-service.koyeb.app;
    
    # SSL configuration
    ssl_certificate /etc/ssl/certs/app.crt;
    ssl_certificate_key /etc/ssl/private/app.key;
    
    location / {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # OAuth2 callback support
        proxy_cookie_path / /;
        proxy_cookie_flags ~ secure samesite=none;
    }
}
</code></pre>
<h2>Testing and Validation Architecture</h2>
<h3>1. Security Integration Testing</h3>
<h4>Test Coverage Matrix</h4>
<pre><code class="language-java">@SpringBootTest
@TestMethodOrder(OrderAnnotation.class)
class OAuth2SecurityArchitectureTest {
    
    @Test @Order(1)
    void testStatelessOAuth2Flow() {
        // Verify cross-instance OAuth2 callback handling
    }
    
    @Test @Order(2) 
    void testUserProvisioningConcurrency() {
        // Test race condition handling in user creation
    }
    
    @Test @Order(3)
    void testReturnUrlSecurity() {
        // Verify origin allowlist enforcement
    }
    
    @Test @Order(4)
    void testCookieSecurityAttributes() {
        // Validate HttpOnly, Secure, SameSite attributes
    }
    
    @Test @Order(5)
    void testCrossOriginAuthentication() {
        // Test SameSite=None cross-origin flows
    }
}
</code></pre>
<h3>2. Security Threat Testing</h3>
<h4>Penetration Testing Scenarios</h4>
<pre><code class="language-java">@TestMethodOrder(OrderAnnotation.class)
class SecurityThreatTest {
    
    @Test @Order(1)
    void testOpenRedirectPrevention() {
        // Attempt malicious return URL injection
    }
    
    @Test @Order(2)
    void testCookieTampering() {
        // Test modified authorization state handling
    }
    
    @Test @Order(3)
    void testSessionFixation() {
        // Verify session security patterns
    }
    
    @Test @Order(4)
    void testCSRFProtection() {
        // Test cross-site request forgery prevention
    }
}
</code></pre>
<h2>Related Documentation</h2>
<ul>
<li><strong>Implementation Patterns</strong>: See <a href="security-implementation-patterns.md">Security Implementation Patterns</a></li>
<li><strong>Configuration Integration</strong>: See <a href="configuration-patterns.md">Configuration Patterns</a></li>
<li><strong>API Documentation</strong>: See <a href="../../api/endpoints/authentication.md">OAuth2 API Documentation</a></li>
<li><strong>Deployment Guide</strong>: See <a href="../deployment/production-deployment.md">Production Deployment</a></li>
<li><strong>Security Compliance</strong>: See <a href="../compliance/security-standards.md">Security Compliance</a></li>
</ul>
<hr>
<p><em>This document provides the comprehensive OAuth2 security architecture for enterprise-grade authentication, stateless session management, and secure cross-origin authentication flows in the SmartSupplyPro inventory management system.</em></p>

  </main>
  <footer>¬© 2025 SmartSupplyPro - Main API Index</footer>
</body>
</html>