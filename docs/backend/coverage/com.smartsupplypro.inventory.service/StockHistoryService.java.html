<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StockHistoryService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Inventory Service</a> &gt; <a href="index.source.html" class="el_package">com.smartsupplypro.inventory.service</a> &gt; <span class="el_source">StockHistoryService.java</span></div><h1>StockHistoryService.java</h1><pre class="source lang-java linenums">package com.smartsupplypro.inventory.service;

import com.smartsupplypro.inventory.dto.StockHistoryDTO;
import com.smartsupplypro.inventory.enums.StockChangeReason;
import com.smartsupplypro.inventory.mapper.StockHistoryMapper;
import com.smartsupplypro.inventory.model.StockHistory;
import com.smartsupplypro.inventory.repository.InventoryItemRepository;
import com.smartsupplypro.inventory.repository.StockHistoryRepository;
import com.smartsupplypro.inventory.validation.StockHistoryValidator;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Service class for managing historical stock movements in the inventory system.
 *
 * &lt;h2&gt;Denormalization Policy&lt;/h2&gt;
 * &lt;p&gt;When persisting a history record, this service resolves and stores the
 * supplier identifier on the {@code StockHistory} row. This denormalization
 * enables efficient supplier-centric analytics (index: SUPPLIER_ID, CREATED_AT)
 * without requiring joins at query time.&lt;/p&gt;
 *
 * &lt;h2&gt;Time Column Mapping&lt;/h2&gt;
 * &lt;p&gt;The domain field {@code timestamp} is persisted to the database column
 * {@code CREATED_AT} to avoid reserved keyword conflicts across databases.&lt;/p&gt;
 */
@Service
@RequiredArgsConstructor
public class StockHistoryService {

    /** JPA repository for stock history persistence operations. */
    private final StockHistoryRepository repository;
    private final InventoryItemRepository itemRepository;

    /**
    * Look up the supplier that owns the given item and return its ID.
    * &lt;p&gt;Returns {@code null} if the item is missing or supplier is not set. The
    * history row remains valid; supplier-based indexes simply wonâ€™t include it.&lt;/p&gt;
    *
    * &lt;p&gt;&lt;b&gt;Performance:&lt;/b&gt; For high-throughput write paths, consider a repository
    * projection returning only (id, supplierId) or passing supplierId directly from
    * the caller if it is already known at the call site.&lt;/p&gt;
    */
    private String resolveSupplierId(String itemId) {
<span class="fc" id="L51">        return itemRepository.findById(itemId)</span>
<span class="fc" id="L52">                .map(item -&gt; item.getSupplierId())</span>
<span class="fc" id="L53">                .orElse(null); // keep null-safe; index still works for present values</span>
    }

    /**
     * @return all stock history entries as DTOs.
     */
    public List&lt;StockHistoryDTO&gt; getAll() {
<span class="nc" id="L60">        return repository.findAll().stream()</span>
<span class="nc" id="L61">                .map(StockHistoryMapper::toDTO)</span>
<span class="nc" id="L62">                .collect(Collectors.toList());</span>
    }

    /**
     * Retrieves all stock history records associated with a given item ID.
     * Uses ordered finder (newest first) if available.
     */
    public List&lt;StockHistoryDTO&gt; getByItemId(String itemId) {
        // Prefer ordered repo method (added in our repository suggestions)
<span class="nc" id="L71">        var list = repository.findByItemIdOrderByTimestampDesc(itemId);</span>
<span class="nc" id="L72">        return list.stream().map(StockHistoryMapper::toDTO).toList();</span>
    }

    /**
     * Retrieves all stock history records for a specific change reason.
     * Uses ordered finder (newest first) if available.
     */
    public List&lt;StockHistoryDTO&gt; getByReason(StockChangeReason reason) {
<span class="nc" id="L80">        var list = repository.findByReasonOrderByTimestampDesc(reason);</span>
<span class="nc" id="L81">        return list.stream().map(StockHistoryMapper::toDTO).toList();</span>
    }

    /**
     * Paginated stock history entries filtered by date range, item name, and supplier ID.
     * Bounds are inclusive. Sorting is applied in the native query (timestamp DESC).
     */
    public Page&lt;StockHistoryDTO&gt; findFiltered(LocalDateTime startDate,
                                              LocalDateTime endDate,
                                              String itemName,
                                              String supplierId,
                                              Pageable pageable) {
<span class="nc" id="L93">        return repository.findFiltered(startDate, endDate, itemName, supplierId, pageable)</span>
<span class="nc" id="L94">                .map(StockHistoryMapper::toDTO);</span>
    }

    /**
     * Logs a new stock change with full validation and timestamping (no price snapshot).
     * &lt;p&gt;Keeps backwards compatibility for existing callers.&lt;/p&gt;
     *
     * @throws IllegalArgumentException if input is invalid
     */
    public void logStockChange(String itemId, int change, StockChangeReason reason, String createdBy) {
        // Delegate to the price-aware overload with a null snapshot
<span class="fc" id="L105">        logStockChange(itemId, change, reason, createdBy, null);</span>
<span class="fc" id="L106">    }</span>

    /**
     * Logs a new stock change with full validation, timestamping, and an optional price snapshot.
     *
     * &lt;p&gt;Use this overload to capture {@code priceAtChange} for analytics, e.g.:
     * &lt;ul&gt;
     *   &lt;li&gt;PRICE_CHANGE events (quantity change == 0)&lt;/li&gt;
     *   &lt;li&gt;Any quantity movement where the current unit price should be recorded&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     *
     * @param itemId        the ID of the item whose stock changed
     * @param change        the quantity change (positive or negative)
     * @param reason        the business reason (enum)
     * @param createdBy     the user (email or ID) who initiated the change
     * @param priceAtChange unit price snapshot at the time of change (nullable)
     * @throws IllegalArgumentException if input is invalid (validator will raise)
     */
    public void logStockChange(String itemId,
                               int change,
                               StockChangeReason reason,
                               String createdBy,
                               BigDecimal priceAtChange) {

        // Validate the enum value &amp; basic constraints
<span class="fc" id="L132">        StockHistoryValidator.validateEnum(reason);</span>

        // Construct a DTO for validation (includes price snapshot when provided)
<span class="fc" id="L135">        StockHistoryDTO dto = StockHistoryDTO.builder()</span>
<span class="fc" id="L136">                .itemId(itemId)</span>
<span class="fc" id="L137">                .change(change)</span>
<span class="fc" id="L138">                .reason(reason.name()) // If DTO already uses enum, set it directly instead of name()</span>
<span class="fc" id="L139">                .createdBy(createdBy)</span>
<span class="fc" id="L140">                .priceAtChange(priceAtChange)</span>
<span class="fc" id="L141">                .build();</span>

        // Business validation (e.g., zero allowed only for PRICE_CHANGE, etc.)
<span class="fc" id="L144">        StockHistoryValidator.validate(dto);</span>

<span class="fc" id="L146">        String supplierId = resolveSupplierId(itemId);</span>

        // Persist entity with server-authoritative timestamp
<span class="fc" id="L149">        StockHistory history = StockHistory.builder()</span>
<span class="fc" id="L150">                .id(&quot;sh-&quot; + itemId + &quot;-&quot; + System.currentTimeMillis())</span>
<span class="fc" id="L151">                .itemId(itemId)</span>
<span class="fc" id="L152">                .supplierId(supplierId)</span>
<span class="fc" id="L153">                .change(change)</span>
<span class="fc" id="L154">                .reason(reason)              // entity uses enum directly</span>
<span class="fc" id="L155">                .createdBy(createdBy)</span>
<span class="fc" id="L156">                .timestamp(LocalDateTime.now())</span>
<span class="fc" id="L157">                .priceAtChange(priceAtChange)</span>
<span class="fc" id="L158">                .build();</span>

<span class="fc" id="L160">        repository.save(history);</span>
<span class="fc" id="L161">    }</span>

    /**
     * Accepts a validated DTO and persists it as a {@link StockHistory} entity.
     * Captures server time and passes through the given price snapshot if present.
     */
    public void save(StockHistoryDTO dto) {
        // Validate DTO with domain rules
<span class="nc" id="L169">        StockHistoryValidator.validate(dto);</span>

<span class="nc" id="L171">        String supplierId = resolveSupplierId(dto.getItemId());</span>

        // Map &amp; persist
<span class="nc" id="L174">        StockHistory history = StockHistory.builder()</span>
<span class="nc" id="L175">                .id(&quot;sh-&quot; + dto.getItemId() + &quot;-&quot; + System.currentTimeMillis())</span>
<span class="nc" id="L176">                .itemId(dto.getItemId())</span>
<span class="nc" id="L177">                .supplierId(supplierId)</span>
<span class="nc" id="L178">                .change(dto.getChange())</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">                .reason(dto.getReason() != null</span>
<span class="nc" id="L180">                        ? StockChangeReason.valueOf(dto.getReason())</span>
<span class="nc" id="L181">                        : null)</span>
<span class="nc" id="L182">                .createdBy(dto.getCreatedBy())</span>
<span class="nc" id="L183">                .timestamp(LocalDateTime.now())</span>
<span class="nc" id="L184">                .priceAtChange(dto.getPriceAtChange())</span>
<span class="nc" id="L185">                .build();</span>

<span class="nc" id="L187">        repository.save(history);</span>
<span class="nc" id="L188">    }</span>

    /**
     * Records a stock deletion operation in the history.
     * &lt;p&gt;Convention: quantity {@code -1} indicates deletion. Retained for backward compatibility.
     * Prefer logging the full negative remaining quantity at call-site when deleting an item.&lt;/p&gt;
     */
    public void delete(String itemId, StockChangeReason reason, String createdBy) {
<span class="fc" id="L196">        logStockChange(itemId, -1, reason, createdBy);</span>
<span class="fc" id="L197">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>