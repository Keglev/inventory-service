<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StockHistoryCustomRepositoryImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Inventory Service</a> &gt; <a href="index.source.html" class="el_package">com.smartsupplypro.inventory.repository.custom</a> &gt; <span class="el_source">StockHistoryCustomRepositoryImpl.java</span></div><h1>StockHistoryCustomRepositoryImpl.java</h1><pre class="source lang-java linenums">package com.smartsupplypro.inventory.repository.custom;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import com.smartsupplypro.inventory.dto.PriceTrendDTO;
import com.smartsupplypro.inventory.dto.StockEventRowDTO;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Query;

/**
 * Custom repository implementation for stock history analytics with database-specific SQL.
 *
 * &lt;p&gt;&lt;strong&gt;Purpose&lt;/strong&gt;:
 * Encapsulates native SQL and JPQL for analytics, supporting both H2 (test) and Oracle (prod)
 * without leaking dialect specifics to controllers or services.
 *
 * &lt;p&gt;&lt;strong&gt;Design Notes&lt;/strong&gt;:
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;strong&gt;Field Mapping&lt;/strong&gt;: timestamp → CREATED_AT, change → CHANGE, priceAtChange → PRICE_AT_CHANGE&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;H2 Mode&lt;/strong&gt;: Uses quoted uppercase identifiers, YEAR/MONTH/DAY functions, CONCAT&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;Oracle Mode&lt;/strong&gt;: Uses unquoted identifiers, TO_CHAR formatting, TRUNC for day grouping&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;Filtering&lt;/strong&gt;: All parameters bound (no string concat) to prevent SQL injection&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;Return Types&lt;/strong&gt;: Object[] for aggregations, StockEventRowDTO for WAC calculations&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @see StockHistoryCustomRepository
 * @see &lt;a href=&quot;../../../../../../../docs/architecture/patterns/repository-patterns.md&quot;&gt;Repository Patterns&lt;/a&gt;
 */
<span class="fc" id="L35">public class StockHistoryCustomRepositoryImpl implements StockHistoryCustomRepository {</span>
    
    @PersistenceContext
    private EntityManager em;
    
    @org.springframework.beans.factory.annotation.Autowired
    private org.springframework.core.env.Environment environment;
    
    /**
     * Detects if H2 profile is active (test/h2) vs Oracle (default/prod).
     *
     * @return true if H2 mode
     */
    private boolean isH2() {
<span class="fc" id="L49">        return Arrays.stream(environment.getActiveProfiles())</span>
<span class="pc bpc" id="L50" title="3 of 4 branches missed.">            .anyMatch(p -&gt; p.equalsIgnoreCase(&quot;test&quot;) || p.equalsIgnoreCase(&quot;h2&quot;));</span>
    }
    
    /**
     * Monthly stock-in/stock-out aggregations over time window (native SQL).
     * Returns: [month (YYYY-MM), stockIn, stockOut]
     *
     * @param start inclusive lower bound
     * @param end inclusive upper bound
     * @return monthly aggregations ordered by month
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;Object[]&gt; getMonthlyStockMovement(LocalDateTime start, LocalDateTime end) {
        final String sql;
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">        if (isH2()) {</span>
<span class="fc" id="L66">            sql = &quot;&quot;&quot;</span>
                SELECT CONCAT(CAST(YEAR(sh.created_at) AS VARCHAR), '-',
                              LPAD(CAST(MONTH(sh.created_at) AS VARCHAR), 2, '0')) AS month_str,
                       SUM(CASE WHEN sh.quantity_change &gt; 0 THEN sh.quantity_change ELSE 0 END) AS stock_in,
                       SUM(CASE WHEN sh.quantity_change &lt; 0 THEN ABS(sh.quantity_change) ELSE 0 END) AS stock_out
                FROM stock_history sh
                WHERE sh.created_at BETWEEN :start AND :end
                GROUP BY CONCAT(CAST(YEAR(sh.created_at) AS VARCHAR), '-',
                                LPAD(CAST(MONTH(sh.created_at) AS VARCHAR), 2, '0'))
                ORDER BY 1
            &quot;&quot;&quot;;
        } else {
<span class="nc" id="L78">            sql = &quot;&quot;&quot;</span>
                SELECT TO_CHAR(sh.created_at, 'YYYY-MM') AS month_str,
                       SUM(CASE WHEN sh.quantity_change &gt; 0 THEN sh.quantity_change ELSE 0 END) AS stock_in,
                       SUM(CASE WHEN sh.quantity_change &lt; 0 THEN ABS(sh.quantity_change) ELSE 0 END) AS stock_out
                FROM stock_history sh
                WHERE sh.created_at BETWEEN :start AND :end
                GROUP BY TO_CHAR(sh.created_at, 'YYYY-MM')
                ORDER BY 1
            &quot;&quot;&quot;;
        }
<span class="fc" id="L88">        Query nativeQuery = em.createNativeQuery(sql);</span>
<span class="fc" id="L89">        nativeQuery.setParameter(&quot;start&quot;, start);</span>
<span class="fc" id="L90">        nativeQuery.setParameter(&quot;end&quot;, end);</span>
<span class="fc" id="L91">        return nativeQuery.getResultList();</span>
    }
    
    /**
     * Monthly stock-in/stock-out filtered by supplier (native SQL).
     * Returns: [month (YYYY-MM), stockIn, stockOut]
     *
     * @param start inclusive lower bound
     * @param end inclusive upper bound
     * @param supplierId optional supplier filter (case-insensitive for H2)
     * @return monthly aggregations ordered by month
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;Object[]&gt; getMonthlyStockMovementFiltered(LocalDateTime start, LocalDateTime end, String supplierId) {
        final String sql;
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        if (isH2()) {</span>
<span class="fc" id="L108">            sql = &quot;&quot;&quot;</span>
                SELECT CONCAT(CAST(YEAR(sh.created_at) AS VARCHAR), '-',
                              LPAD(CAST(MONTH(sh.created_at) AS VARCHAR), 2, '0')) AS month_str,
                       SUM(CASE WHEN sh.quantity_change &gt; 0 THEN sh.quantity_change ELSE 0 END) AS stock_in,
                       SUM(CASE WHEN sh.quantity_change &lt; 0 THEN ABS(sh.quantity_change) ELSE 0 END) AS stock_out
                FROM stock_history sh
                JOIN inventory_item i ON sh.item_id = i.id
                WHERE sh.created_at BETWEEN :start AND :end
                  AND (:supplierId IS NULL OR UPPER(i.supplier_id) = UPPER(:supplierId))
                GROUP BY CONCAT(CAST(YEAR(sh.created_at) AS VARCHAR), '-',
                                LPAD(CAST(MONTH(sh.created_at) AS VARCHAR), 2, '0'))
                ORDER BY 1
            &quot;&quot;&quot;;
        } else {
<span class="nc" id="L122">            sql = &quot;&quot;&quot;</span>
                SELECT TO_CHAR(sh.created_at, 'YYYY-MM') AS month_str,
                       SUM(CASE WHEN sh.quantity_change &gt; 0 THEN sh.quantity_change ELSE 0 END) AS stock_in,
                       SUM(CASE WHEN sh.quantity_change &lt; 0 THEN ABS(sh.quantity_change) ELSE 0 END) AS stock_out
                FROM stock_history sh
                JOIN inventory_item i ON sh.item_id = i.id
                WHERE sh.created_at BETWEEN :start AND :end
                  AND (:supplierId IS NULL OR i.supplier_id = :supplierId)
                GROUP BY TO_CHAR(sh.created_at, 'YYYY-MM')
                ORDER BY 1
            &quot;&quot;&quot;;
        }
<span class="pc bpc" id="L134" title="2 of 4 branches missed.">        final String normalizedSupplier = (supplierId == null || supplierId.isBlank()) ? null : supplierId;</span>
<span class="fc" id="L135">        final Query nativeQuery = em.createNativeQuery(sql);</span>
<span class="fc" id="L136">        nativeQuery.setParameter(&quot;start&quot;, start);</span>
<span class="fc" id="L137">        nativeQuery.setParameter(&quot;end&quot;, end);</span>
<span class="fc" id="L138">        nativeQuery.setParameter(&quot;supplierId&quot;, normalizedSupplier);</span>
<span class="fc" id="L139">        return nativeQuery.getResultList();</span>
    }
    
    /**
    * Daily total stock value (quantity × price) for a time window, optionally filtered by supplier.
    *
    * &lt;p&gt;Returns a real DATE in column 1 to align with service mapping
    * (&lt;code&gt;(Date) row[0]&lt;/code&gt; → &lt;code&gt;toLocalDate()&lt;/code&gt;), not a string.&lt;/p&gt;
    *
    * &lt;p&gt;&lt;strong&gt;Output row format:&lt;/strong&gt; [day_date (DATE), total_value (Number)]&lt;/p&gt;
    *
    * &lt;p&gt;Definition of “daily value”:
    * For each item on a given calendar day, compute the &lt;em&gt;closing quantity&lt;/em&gt; as the
    * cumulative sum of {@code quantity_change} up to the last event of that day, then multiply
    * by the price at that change (fallback to {@code inventory_item.price} when null).
    * Sum across items for that day.&lt;/p&gt;
    *
    * @param start      inclusive lower bound
    * @param end        inclusive upper bound
    * @param supplierId optional supplier filter (null or blank = all)
    * @return rows ordered by day ascending
    */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;Object[]&gt; getStockValueGroupedByDateFiltered(
    LocalDateTime start, LocalDateTime end, String supplierId) {
        
        final String sql;
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if (isH2()) {</span>
            // H2: CAST to DATE; window functions are supported in H2 2.x
<span class="fc" id="L169">            sql = &quot;&quot;&quot;</span>
            WITH events AS (
                SELECT
                    CAST(sh.created_at AS DATE) AS day_date,
                    sh.item_id                  AS item_id,
                    sh.created_at               AS created_at,
                    sh.quantity_change          AS quantity_change,
                    sh.price_at_change          AS price_at_change,
                    /* Running balance per item up to the current row = closing qty at day's last row */
                    SUM(sh.quantity_change) OVER (
                        PARTITION BY sh.item_id
                        ORDER BY sh.created_at
                        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                    )                           AS qty_after,
                    ROW_NUMBER() OVER (
                        PARTITION BY CAST(sh.created_at AS DATE), sh.item_id
                        ORDER BY sh.created_at DESC
                    )                           AS rn
                FROM stock_history sh
                JOIN inventory_item i ON i.id = sh.item_id
                WHERE sh.created_at BETWEEN :start AND :end
                  AND (:supplierId IS NULL OR UPPER(i.supplier_id) = UPPER(:supplierId))
            )
            SELECT
                e.day_date,
                SUM(
                    COALESCE(e.qty_after, 0) * COALESCE(e.price_at_change, i.price, 0)
                ) AS total_value
            FROM events e
            JOIN inventory_item i ON i.id = e.item_id
            WHERE e.rn = 1
            GROUP BY e.day_date
            ORDER BY e.day_date
        &quot;&quot;&quot;;
        } else {
            // Oracle: TRUNC to day, cast to DATE for clarity; analytic SUM works the same
<span class="nc" id="L205">            sql = &quot;&quot;&quot;</span>
            WITH events AS (
                SELECT
                    CAST(TRUNC(sh.created_at) AS DATE) AS day_date,
                    sh.item_id                           AS item_id,
                    sh.created_at                        AS created_at,
                    sh.quantity_change                   AS quantity_change,
                    sh.price_at_change                   AS price_at_change,
                    SUM(sh.quantity_change) OVER (
                        PARTITION BY sh.item_id
                        ORDER BY sh.created_at
                    )                                    AS qty_after,
                    ROW_NUMBER() OVER (
                        PARTITION BY TRUNC(sh.created_at), sh.item_id
                        ORDER BY sh.created_at DESC
                    )                                    AS rn
                FROM stock_history sh
                JOIN inventory_item i ON i.id = sh.item_id
                WHERE sh.created_at BETWEEN :start AND :end
                  AND (:supplierId IS NULL OR i.supplier_id = :supplierId)
            )
            SELECT
                e.day_date,
                SUM(
                    COALESCE(e.qty_after, 0) * COALESCE(e.price_at_change, i.price, 0)
                ) AS total_value
            FROM events e
            JOIN inventory_item i ON i.id = e.item_id
            WHERE e.rn = 1
            GROUP BY e.day_date
            ORDER BY e.day_date
        &quot;&quot;&quot;;
        }
        
        final String normalizedSupplier =
<span class="pc bpc" id="L240" title="3 of 4 branches missed.">        (supplierId == null || supplierId.isBlank()) ? null : supplierId.trim();</span>
        
        // Use Timestamps explicitly for both H2 and Oracle drivers
<span class="fc" id="L243">        final java.sql.Timestamp startTs = java.sql.Timestamp.valueOf(start);</span>
<span class="fc" id="L244">        final java.sql.Timestamp endTs   = java.sql.Timestamp.valueOf(end);</span>
        
<span class="fc" id="L246">        final Query nativeQuery = em.createNativeQuery(sql);</span>
<span class="fc" id="L247">        nativeQuery.setParameter(&quot;start&quot;, startTs);</span>
<span class="fc" id="L248">        nativeQuery.setParameter(&quot;end&quot;, endTs);</span>
<span class="fc" id="L249">        nativeQuery.setParameter(&quot;supplierId&quot;, normalizedSupplier);</span>
        
<span class="fc" id="L251">        return nativeQuery.getResultList();</span>
    }
    
    
    /**
     * Returns total stock quantity per supplier for dashboard (native SQL).
     * Returns: [supplier_name (String), total_quantity (Number)]
     *
     * @return per-supplier totals ordered by quantity descending
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;Object[]&gt; getTotalStockPerSupplier() {
        final String sql;
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">        if (isH2()) {</span>
<span class="fc" id="L266">            sql = &quot;&quot;&quot;</span>
                SELECT s.&quot;NAME&quot; AS supplier_name, SUM(i.&quot;QUANTITY&quot;) AS total_quantity
                FROM &quot;SUPPLIER&quot; s
                JOIN &quot;INVENTORY_ITEM&quot; i ON s.&quot;ID&quot; = i.&quot;SUPPLIER_ID&quot;
                GROUP BY s.&quot;NAME&quot;
                ORDER BY total_quantity DESC
            &quot;&quot;&quot;;
        } else {
<span class="nc" id="L274">            sql = &quot;&quot;&quot;</span>
                SELECT s.name AS supplier_name, SUM(i.quantity) AS total_quantity
            FROM supplier s
            JOIN inventory_item i ON s.id = i.supplier_id
            GROUP BY s.name
            ORDER BY total_quantity DESC
            &quot;&quot;&quot;;
        }
<span class="fc" id="L282">        return em.createNativeQuery(sql).getResultList();</span>
    }
    
    /**
     * Returns update event count per item with optional supplier filtering (native SQL).
     * Returns: [item_name (String), update_count (Number)]
     *
     * @param supplierId optional supplier ID filter (case-insensitive)
     * @return per-item update counts ordered by count descending
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;Object[]&gt; getUpdateCountPerItemFiltered(String supplierId) {
        final String sql;
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if (isH2()) {</span>
<span class="fc" id="L297">            sql = &quot;&quot;&quot;</span>
                SELECT i.&quot;NAME&quot; AS item_name, COUNT(sh.&quot;ID&quot;) AS update_count
                FROM &quot;INVENTORY_ITEM&quot; i
                JOIN &quot;STOCK_HISTORY&quot; sh ON sh.&quot;ITEM_ID&quot; = i.&quot;ID&quot;
                WHERE (:supplierId IS NULL OR UPPER(i.&quot;SUPPLIER_ID&quot;) = UPPER(:supplierId))
                GROUP BY i.&quot;NAME&quot;
                ORDER BY update_count DESC
            &quot;&quot;&quot;;
        } else {
<span class="nc" id="L306">            sql = &quot;&quot;&quot;</span>
                SELECT i.name AS item_name, COUNT(sh.id) AS update_count
            FROM stock_history sh
            JOIN inventory_item i ON sh.item_id = i.id
            WHERE (:supplierId IS NULL OR UPPER(i.supplier_id) = UPPER(:supplierId))
            GROUP BY i.name
            ORDER BY update_count DESC
            &quot;&quot;&quot;;
        }
<span class="pc bpc" id="L315" title="2 of 4 branches missed.">        final String normalizedSupplier = (supplierId == null || supplierId.isBlank()) ? null : supplierId;</span>
<span class="fc" id="L316">        final Query nativeQuery = em.createNativeQuery(sql);</span>
<span class="fc" id="L317">        nativeQuery.setParameter(&quot;supplierId&quot;, normalizedSupplier);</span>
<span class="fc" id="L318">        return nativeQuery.getResultList();</span>
    }
    
    /**
     * Returns items currently below their minimum stock threshold (native SQL).
     * Returns: [name (String), quantity (Number), minimum_quantity (Number)]
     *
     * @param supplierId optional supplier ID filter (case-insensitive)
     * @return items below minimum ordered by severity
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;Object[]&gt; findItemsBelowMinimumStockFiltered(String supplierId) {
        final String sql;
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">        if (isH2()) {</span>
<span class="fc" id="L333">            sql = &quot;&quot;&quot;</span>
                SELECT i.&quot;NAME&quot;, i.&quot;QUANTITY&quot;, i.&quot;MINIMUM_QUANTITY&quot;
                FROM &quot;INVENTORY_ITEM&quot; i
                WHERE i.&quot;QUANTITY&quot; &lt; i.&quot;MINIMUM_QUANTITY&quot;
                  AND (:supplierId IS NULL OR UPPER(i.&quot;SUPPLIER_ID&quot;) = UPPER(:supplierId))
                ORDER BY i.&quot;QUANTITY&quot; ASC
            &quot;&quot;&quot;;
        } else {
<span class="nc" id="L341">            sql = &quot;&quot;&quot;</span>
                SELECT i.name, i.quantity, i.minimum_quantity
            FROM inventory_item i
            WHERE i.quantity &lt; i.minimum_quantity
              AND (:supplierId IS NULL OR UPPER(i.supplier_id) = UPPER(:supplierId))
            ORDER BY i.quantity ASC
            &quot;&quot;&quot;;
        }
<span class="pc bpc" id="L349" title="2 of 4 branches missed.">        final String normalizedSupplier = (supplierId == null || supplierId.isBlank()) ? null : supplierId;</span>
<span class="fc" id="L350">        final Query nativeQuery = em.createNativeQuery(sql);</span>
<span class="fc" id="L351">        nativeQuery.setParameter(&quot;supplierId&quot;, normalizedSupplier);</span>
<span class="fc" id="L352">        return nativeQuery.getResultList();</span>
    }
    
    /**
     * Returns stock updates with flexible multi-criteria filtering (native SQL).
     * Returns: [item_name, supplier_name, quantity_change, reason, created_by, created_at]
     *
     * @param startDate optional minimum creation timestamp
     * @param endDate optional maximum creation timestamp
     * @param itemName optional item name filter (case-insensitive partial match)
     * @param supplierId optional supplier ID filter
     * @param createdBy optional creator username filter (case-insensitive exact match)
     * @param minChange optional minimum quantity change filter
     * @param maxChange optional maximum quantity change filter
     * @return filtered stock updates ordered by creation time descending
     * @see com.smartsupplypro.inventory.repository for parameter normalization patterns
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;Object[]&gt; findFilteredStockUpdates(
    LocalDateTime startDate,
    LocalDateTime endDate,
    String itemName,
    String supplierId,
    String createdBy,
    Integer minChange,
    Integer maxChange
    ) {
        // Enterprise Comment: Multi-Criteria Filtering Pattern
        // Uses NULL-safe WHERE clauses allowing optional filters. Each parameter
        // is normalized (null/blank checks) and converted to search patterns
        // (e.g., LIKE %term% for partial match). This enables flexible queries
        // without building dynamic SQL strings.
        final String sql;
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        if (isH2()) {</span>
<span class="fc" id="L387">            sql = &quot;&quot;&quot;</span>
                SELECT i.name AS item_name, s.name AS supplier_name, sh.quantity_change, sh.reason, sh.created_by, sh.created_at
                FROM stock_history sh
                JOIN inventory_item i ON sh.item_id = i.id
                JOIN supplier s ON i.supplier_id = s.id
                WHERE (:startDate     IS NULL OR sh.created_at &gt;= :startDate)
                  AND (:endDate       IS NULL OR sh.created_at &lt;= :endDate)
                  AND (:itemPattern   IS NULL OR LOWER(i.name) LIKE :itemPattern)
                  AND (:supplierId    IS NULL OR UPPER(i.supplier_id) = UPPER(:supplierId))
                  AND (:createdByNorm IS NULL OR LOWER(sh.created_by) = :createdByNorm)
                  AND (:minChange     IS NULL OR sh.quantity_change &gt;= :minChange)
                  AND (:maxChange     IS NULL OR sh.quantity_change &lt;= :maxChange)
                ORDER BY sh.created_at DESC
            &quot;&quot;&quot;;
        } else {
<span class="nc" id="L402">            sql = &quot;&quot;&quot;</span>
                SELECT i.name AS item_name, s.name AS supplier_name, sh.quantity_change, sh.reason, sh.created_by, sh.created_at
                FROM stock_history sh
                JOIN inventory_item i ON sh.item_id = i.id
                JOIN supplier s ON i.supplier_id = s.id
                WHERE (:startDate     IS NULL OR sh.created_at &gt;= :startDate)
                  AND (:endDate       IS NULL OR sh.created_at &lt;= :endDate)
                  AND (:itemPattern   IS NULL OR LOWER(i.name) LIKE :itemPattern)
                  AND (:supplierId    IS NULL OR i.supplier_id = :supplierId)
                  AND (:createdByNorm IS NULL OR LOWER(sh.created_by) = :createdByNorm)
                  AND (:minChange     IS NULL OR sh.quantity_change &gt;= :minChange)
                  AND (:maxChange     IS NULL OR sh.quantity_change &lt;= :maxChange)
                ORDER BY sh.created_at DESC
            &quot;&quot;&quot;;
        }
<span class="pc bpc" id="L417" title="2 of 4 branches missed.">        final String itemPattern     = (itemName == null || itemName.isBlank()) ? null : &quot;%&quot; + itemName.toLowerCase() + &quot;%&quot;;</span>
<span class="pc bpc" id="L418" title="2 of 4 branches missed.">        final String normalizedSupp  = (supplierId == null || supplierId.isBlank()) ? null : supplierId;</span>
<span class="pc bpc" id="L419" title="2 of 4 branches missed.">        final String createdByNorm   = (createdBy == null || createdBy.isBlank()) ? null : createdBy.toLowerCase();</span>
        
<span class="fc" id="L421">        final Query q = em.createNativeQuery(sql);</span>
<span class="fc" id="L422">        q.setParameter(&quot;startDate&quot;, startDate);</span>
<span class="fc" id="L423">        q.setParameter(&quot;endDate&quot;, endDate);</span>
<span class="fc" id="L424">        q.setParameter(&quot;itemPattern&quot;, itemPattern);</span>
<span class="fc" id="L425">        q.setParameter(&quot;supplierId&quot;, normalizedSupp);</span>
<span class="fc" id="L426">        q.setParameter(&quot;createdByNorm&quot;, createdByNorm);</span>
<span class="fc" id="L427">        q.setParameter(&quot;minChange&quot;, minChange);</span>
<span class="fc" id="L428">        q.setParameter(&quot;maxChange&quot;, maxChange);</span>
        
<span class="fc" id="L430">        return q.getResultList();</span>
    }
    
    /**
     * Returns daily average price trend for specific item (native SQL).
     * Returns: [day_str (String YYYY-MM-DD), price (BigDecimal)]
     *
     * @param itemId required item ID
     * @param supplierId optional supplier ID filter
     * @param start inclusive lower bound timestamp
     * @param end inclusive upper bound timestamp
     * @return daily price trend ordered by day ascending
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;PriceTrendDTO&gt; getPriceTrend(String itemId, String supplierId, LocalDateTime start, LocalDateTime end) {
        final String sql;
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        if (isH2()) {</span>
<span class="fc" id="L448">            sql = &quot;&quot;&quot;</span>
                SELECT CONCAT(
                           CAST(YEAR(sh.created_at) AS VARCHAR), '-',
                           LPAD(CAST(MONTH(sh.created_at) AS VARCHAR), 2, '0'), '-',
                           LPAD(CAST(DAY(sh.created_at) AS VARCHAR), 2, '0')
                       ) AS day_str,
                       AVG(sh.price_at_change) AS price
                FROM stock_history sh
                JOIN inventory_item i ON sh.item_id = i.id
                WHERE sh.created_at BETWEEN :start AND :end
                  AND sh.item_id = :itemId
                  AND (:supplierId IS NULL OR UPPER(i.supplier_id) = UPPER(:supplierId))
                GROUP BY CONCAT(
                           CAST(YEAR(sh.created_at) AS VARCHAR), '-',
                           LPAD(CAST(MONTH(sh.created_at) AS VARCHAR), 2, '0'), '-',
                           LPAD(CAST(DAY(sh.created_at) AS VARCHAR), 2, '0')
                       )
                ORDER BY 1
            &quot;&quot;&quot;;
        } else {
<span class="nc" id="L468">            sql = &quot;&quot;&quot;</span>
                SELECT TO_CHAR(sh.created_at, 'YYYY-MM-DD') AS day_str,
                       AVG(sh.price_at_change) AS price
                FROM stock_history sh
                JOIN inventory_item i ON sh.item_id = i.id
                WHERE sh.created_at BETWEEN :start AND :end
                  AND sh.item_id = :itemId
                  AND (:supplierId IS NULL OR i.supplier_id = :supplierId)
                GROUP BY TO_CHAR(sh.created_at, 'YYYY-MM-DD')
                ORDER BY 1
            &quot;&quot;&quot;;
        }
<span class="pc bpc" id="L480" title="2 of 4 branches missed.">        final String normalizedSupplier = (supplierId == null || supplierId.isBlank()) ? null : supplierId;</span>
        
<span class="fc" id="L482">        final Query q = em.createNativeQuery(sql);</span>
<span class="fc" id="L483">        q.setParameter(&quot;start&quot;, start);</span>
<span class="fc" id="L484">        q.setParameter(&quot;end&quot;, end);</span>
<span class="fc" id="L485">        q.setParameter(&quot;itemId&quot;, itemId);</span>
<span class="fc" id="L486">        q.setParameter(&quot;supplierId&quot;, normalizedSupplier);</span>
        
<span class="fc" id="L488">        final List&lt;Object[]&gt; raw = q.getResultList();</span>
<span class="fc" id="L489">        return raw.stream()</span>
<span class="fc" id="L490">        .map(r -&gt; new PriceTrendDTO((String) r[0], (BigDecimal) r[1]))</span>
<span class="fc" id="L491">        .collect(Collectors.toList());</span>
    }
    
    /**
     * Streams stock events up to specified time for WAC algorithm (JPQL).
     * Used to replay events for opening inventory and aggregate purchases/COGS within window.
     *
     * @param end inclusive upper bound timestamp
     * @param supplierId optional supplier filter
     * @return ordered event stream projected to StockEventRowDTO
     * @see com.smartsupplypro.inventory.service for WAC cost-flow calculations
     */
    @Override
    public List&lt;StockEventRowDTO&gt; findEventsUpTo(LocalDateTime end, String supplierId) {
        // Enterprise Comment: WAC Event Streaming
        // Provides time-ordered event stream for Weighted Average Cost calculations.
        // Events are sorted by item and timestamp to enable sequential replay for
        // opening inventory reconstruction and period-specific cost aggregations.
<span class="fc" id="L509">        final String jpql = &quot;&quot;&quot;</span>
            select new com.smartsupplypro.inventory.dto.StockEventRowDTO(
                sh.itemId, 
                coalesce(sh.supplierId, i.supplierId), 
                sh.timestamp, 
                sh.change,
                sh.priceAtChange,
                sh.reason
            )
            from StockHistory sh, InventoryItem i
            where i.id = sh.itemId 
                and sh.timestamp &lt;= :end
                and (
                    :supplierIdNorm is null 
                    or lower(sh.supplierId) = :supplierIdNorm
                )
            order by sh.itemId asc, sh.timestamp asc
        &quot;&quot;&quot;;

        final String supplierIdNorm = 
<span class="pc bpc" id="L529" title="2 of 4 branches missed.">            (supplierId == null || supplierId.isBlank()) ? null : supplierId.trim().toLowerCase();</span>

<span class="fc" id="L531">        return em.createQuery(jpql, StockEventRowDTO.class)</span>
<span class="fc" id="L532">                .setParameter(&quot;end&quot;, end)</span>
<span class="fc" id="L533">                .setParameter(&quot;supplierIdNorm&quot;, supplierIdNorm)</span>
<span class="fc" id="L534">                .getResultList();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>