<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StockHistoryCustomRepositoryImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Inventory Service</a> &gt; <a href="index.source.html" class="el_package">com.smartsupplypro.inventory.repository.custom</a> &gt; <span class="el_source">StockHistoryCustomRepositoryImpl.java</span></div><h1>StockHistoryCustomRepositoryImpl.java</h1><pre class="source lang-java linenums">package com.smartsupplypro.inventory.repository.custom;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import com.smartsupplypro.inventory.dto.PriceTrendDTO;
import com.smartsupplypro.inventory.dto.StockEventRowDTO;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.Query;

/**
* Custom repository implementation for analytics queries over STOCK_HISTORY.
*
* &lt;h2&gt;Purpose&lt;/h2&gt;
* Encapsulates all native SQL / JPQL needed by analytics so we can:
* &lt;ul&gt;
*   &lt;li&gt;Support both H2 (test profile) and Oracle (prod) without leaking dialect specifics upward.&lt;/li&gt;
*   &lt;li&gt;Keep controllers/services DB-agnostic (only rely on entity properties or DTOs).&lt;/li&gt;
*   &lt;li&gt;Centralize SQL tuning (indexes, hints, date truncation functions, etc.).&lt;/li&gt;
* &lt;/ul&gt;
*
* &lt;h2&gt;Entity / Column conventions&lt;/h2&gt;
* &lt;ul&gt;
*   &lt;li&gt;&lt;code&gt;StockHistory.timestamp&lt;/code&gt; → DB column &lt;code&gt;CREATED_AT&lt;/code&gt; (DATE/TIMESTAMP)&lt;/li&gt;
*   &lt;li&gt;&lt;code&gt;StockHistory.change&lt;/code&gt;    → DB column &lt;code&gt;&quot;CHANGE&quot;&lt;/code&gt; (NUMBER/INT)&lt;/li&gt;
*   &lt;li&gt;&lt;code&gt;StockHistory.priceAtChange&lt;/code&gt; → DB column &lt;code&gt;&quot;PRICE_AT_CHANGE&quot;&lt;/code&gt;&lt;/li&gt;
*   &lt;li&gt;&lt;code&gt;StockHistory.itemId&lt;/code&gt;    → DB column &lt;code&gt;&quot;ITEM_ID&quot;&lt;/code&gt;&lt;/li&gt;
*   &lt;li&gt;&lt;code&gt;StockHistory.supplierId&lt;/code&gt;→ DB column &lt;code&gt;&quot;SUPPLIER_ID&quot;&lt;/code&gt;&lt;/li&gt;
*   &lt;li&gt;H2 branch uses quoted UPPERCASE identifiers (e.g., &lt;code&gt;&quot;STOCK_HISTORY&quot;&lt;/code&gt;) to match how
*       Hibernate created the tables in tests; Oracle branch uses unquoted identifiers.&lt;/li&gt;
*   &lt;li&gt;All parameters are bound (no string concatenation) to avoid SQL injection.&lt;/li&gt;
* &lt;/ul&gt;
*
* &lt;h2&gt;Filtering conventions&lt;/h2&gt;&lt;h2&gt;H2 vs Oracle&lt;/h2&gt;
* &lt;ul&gt;
*   &lt;li&gt;H2 (Oracle mode): use &lt;code&gt;YEAR()/MONTH()/DAY()&lt;/code&gt;, &lt;code&gt;CAST(... AS DATE)&lt;/code&gt;, string &lt;code&gt;CONCAT&lt;/code&gt;.&lt;/li&gt;
*   &lt;li&gt;Oracle: use &lt;code&gt;TO_CHAR(...)&lt;/code&gt; for formatting, &lt;code&gt;TRUNC(...)&lt;/code&gt; for day grouping.&lt;/li&gt;
*   &lt;li&gt;Table/column names are unquoted, case‑insensitive, and identical across DBs.&lt;/li&gt;
* &lt;/ul&gt;
*
* &lt;h2&gt;Return shapes&lt;/h2&gt;
* &lt;ul&gt;
*   &lt;li&gt;Most native methods return &lt;code&gt;List&amp;lt;Object[]&amp;gt;&lt;/code&gt; for simple aggregations.&lt;/li&gt;
*   &lt;li&gt;Event streaming for cost-flow (WAC) uses a constructor projection into
*       {@link com.smartsupplypro.inventory.dto.StockEventRowDTO} via JPQL.&lt;/li&gt;
* &lt;/ul&gt;
*/
<span class="fc" id="L53">public class StockHistoryCustomRepositoryImpl implements StockHistoryCustomRepository {</span>
    
    @PersistenceContext
    private EntityManager em;
    
    @org.springframework.beans.factory.annotation.Autowired
    private org.springframework.core.env.Environment environment;
    
    /**
    * Detects whether we should run H2-compatible SQL (test/h2 profiles) or Oracle SQL (default/prod).
    */
    private boolean isH2() {
<span class="fc" id="L65">        return Arrays.stream(environment.getActiveProfiles())</span>
<span class="pc bpc" id="L66" title="3 of 4 branches missed.">            .anyMatch(p -&gt; p.equalsIgnoreCase(&quot;test&quot;) || p.equalsIgnoreCase(&quot;h2&quot;));</span>
    }
    
    /**
    * Monthly stock movement (stock-in / stock-out) over a time window.
    *
    * &lt;p&gt;&lt;strong&gt;Output row format:&lt;/strong&gt; [month_str (YYYY-MM), stock_in (Number), stock_out (Number)]&lt;/p&gt;
    *
    * @param start inclusive lower bound (uses &lt;code&gt;created_at&lt;/code&gt;)
    * @param end   inclusive upper bound (uses &lt;code&gt;created_at&lt;/code&gt;)
    * @return aggregated rows ordered by month ascending
    */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;Object[]&gt; getMonthlyStockMovement(LocalDateTime start, LocalDateTime end) {
        final String sql;
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        if (isH2()) {</span>
<span class="fc" id="L83">            sql = &quot;&quot;&quot;</span>
                SELECT CONCAT(CAST(YEAR(sh.created_at) AS VARCHAR), '-',
                              LPAD(CAST(MONTH(sh.created_at) AS VARCHAR), 2, '0')) AS month_str,
                       SUM(CASE WHEN sh.quantity_change &gt; 0 THEN sh.quantity_change ELSE 0 END) AS stock_in,
                       SUM(CASE WHEN sh.quantity_change &lt; 0 THEN ABS(sh.quantity_change) ELSE 0 END) AS stock_out
                FROM stock_history sh
                WHERE sh.created_at BETWEEN :start AND :end
                GROUP BY CONCAT(CAST(YEAR(sh.created_at) AS VARCHAR), '-',
                                LPAD(CAST(MONTH(sh.created_at) AS VARCHAR), 2, '0'))
                ORDER BY 1
            &quot;&quot;&quot;;
        } else {
<span class="nc" id="L95">            sql = &quot;&quot;&quot;</span>
                SELECT TO_CHAR(sh.created_at, 'YYYY-MM') AS month_str,
                       SUM(CASE WHEN sh.quantity_change &gt; 0 THEN sh.quantity_change ELSE 0 END) AS stock_in,
                       SUM(CASE WHEN sh.quantity_change &lt; 0 THEN ABS(sh.quantity_change) ELSE 0 END) AS stock_out
                FROM stock_history sh
                WHERE sh.created_at BETWEEN :start AND :end
                GROUP BY TO_CHAR(sh.created_at, 'YYYY-MM')
                ORDER BY 1
            &quot;&quot;&quot;;
        }
<span class="fc" id="L105">        Query nativeQuery = em.createNativeQuery(sql);</span>
<span class="fc" id="L106">        nativeQuery.setParameter(&quot;start&quot;, start);</span>
<span class="fc" id="L107">        nativeQuery.setParameter(&quot;end&quot;, end);</span>
<span class="fc" id="L108">        return nativeQuery.getResultList();</span>
    }
    
    /**
    * Monthly stock movement (stock-in / stock-out) filtered by supplier over a time window.
    *
    * &lt;p&gt;&lt;strong&gt;Output row format:&lt;/strong&gt; [month_str (YYYY-MM), stock_in (Number), stock_out (Number)]&lt;/p&gt;
    *
    * @param start      inclusive lower bound
    * @param end        inclusive upper bound
    * @param supplierId optional supplier ID (case-insensitive for H2 branch)
    * @return aggregated rows ordered by month ascending
    */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;Object[]&gt; getMonthlyStockMovementFiltered(LocalDateTime start, LocalDateTime end, String supplierId) {
        final String sql;
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (isH2()) {</span>
<span class="fc" id="L126">            sql = &quot;&quot;&quot;</span>
                SELECT CONCAT(CAST(YEAR(sh.created_at) AS VARCHAR), '-',
                              LPAD(CAST(MONTH(sh.created_at) AS VARCHAR), 2, '0')) AS month_str,
                       SUM(CASE WHEN sh.quantity_change &gt; 0 THEN sh.quantity_change ELSE 0 END) AS stock_in,
                       SUM(CASE WHEN sh.quantity_change &lt; 0 THEN ABS(sh.quantity_change) ELSE 0 END) AS stock_out
                FROM stock_history sh
                JOIN inventory_item i ON sh.item_id = i.id
                WHERE sh.created_at BETWEEN :start AND :end
                  AND (:supplierId IS NULL OR UPPER(i.supplier_id) = UPPER(:supplierId))
                GROUP BY CONCAT(CAST(YEAR(sh.created_at) AS VARCHAR), '-',
                                LPAD(CAST(MONTH(sh.created_at) AS VARCHAR), 2, '0'))
                ORDER BY 1
            &quot;&quot;&quot;;
        } else {
<span class="nc" id="L140">            sql = &quot;&quot;&quot;</span>
                SELECT TO_CHAR(sh.created_at, 'YYYY-MM') AS month_str,
                       SUM(CASE WHEN sh.quantity_change &gt; 0 THEN sh.quantity_change ELSE 0 END) AS stock_in,
                       SUM(CASE WHEN sh.quantity_change &lt; 0 THEN ABS(sh.quantity_change) ELSE 0 END) AS stock_out
                FROM stock_history sh
                JOIN inventory_item i ON sh.item_id = i.id
                WHERE sh.created_at BETWEEN :start AND :end
                  AND (:supplierId IS NULL OR i.supplier_id = :supplierId)
                GROUP BY TO_CHAR(sh.created_at, 'YYYY-MM')
                ORDER BY 1
            &quot;&quot;&quot;;
        }
<span class="pc bpc" id="L152" title="2 of 4 branches missed.">        final String normalizedSupplier = (supplierId == null || supplierId.isBlank()) ? null : supplierId;</span>
<span class="fc" id="L153">        final Query nativeQuery = em.createNativeQuery(sql);</span>
<span class="fc" id="L154">        nativeQuery.setParameter(&quot;start&quot;, start);</span>
<span class="fc" id="L155">        nativeQuery.setParameter(&quot;end&quot;, end);</span>
<span class="fc" id="L156">        nativeQuery.setParameter(&quot;supplierId&quot;, normalizedSupplier);</span>
<span class="fc" id="L157">        return nativeQuery.getResultList();</span>
    }
    
    /**
    * Daily total stock value (quantity × price) for a time window, optionally filtered by supplier.
    *
    * &lt;p&gt;Returns a real DATE in column 1 to align with service mapping
    * (&lt;code&gt;(Date) row[0]&lt;/code&gt; → &lt;code&gt;toLocalDate()&lt;/code&gt;), not a string.&lt;/p&gt;
    *
    * &lt;p&gt;&lt;strong&gt;Output row format:&lt;/strong&gt; [day_date (DATE), total_value (Number)]&lt;/p&gt;
    *
    * &lt;p&gt;Definition of “daily value”:
    * For each item on a given calendar day, compute the &lt;em&gt;closing quantity&lt;/em&gt; as the
    * cumulative sum of {@code quantity_change} up to the last event of that day, then multiply
    * by the price at that change (fallback to {@code inventory_item.price} when null).
    * Sum across items for that day.&lt;/p&gt;
    *
    * @param start      inclusive lower bound
    * @param end        inclusive upper bound
    * @param supplierId optional supplier filter (null or blank = all)
    * @return rows ordered by day ascending
    */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;Object[]&gt; getStockValueGroupedByDateFiltered(
    LocalDateTime start, LocalDateTime end, String supplierId) {
        
        final String sql;
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (isH2()) {</span>
            // H2: CAST to DATE; window functions are supported in H2 2.x
<span class="fc" id="L187">            sql = &quot;&quot;&quot;</span>
            WITH events AS (
                SELECT
                    CAST(sh.created_at AS DATE) AS day_date,
                    sh.item_id                  AS item_id,
                    sh.created_at               AS created_at,
                    sh.quantity_change          AS quantity_change,
                    sh.price_at_change          AS price_at_change,
                    /* Running balance per item up to the current row = closing qty at day's last row */
                    SUM(sh.quantity_change) OVER (
                        PARTITION BY sh.item_id
                        ORDER BY sh.created_at
                        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                    )                           AS qty_after,
                    ROW_NUMBER() OVER (
                        PARTITION BY CAST(sh.created_at AS DATE), sh.item_id
                        ORDER BY sh.created_at DESC
                    )                           AS rn
                FROM stock_history sh
                JOIN inventory_item i ON i.id = sh.item_id
                WHERE sh.created_at BETWEEN :start AND :end
                  AND (:supplierId IS NULL OR UPPER(i.supplier_id) = UPPER(:supplierId))
            )
            SELECT
                e.day_date,
                SUM(
                    COALESCE(e.qty_after, 0) * COALESCE(e.price_at_change, i.price, 0)
                ) AS total_value
            FROM events e
            JOIN inventory_item i ON i.id = e.item_id
            WHERE e.rn = 1
            GROUP BY e.day_date
            ORDER BY e.day_date
        &quot;&quot;&quot;;
        } else {
            // Oracle: TRUNC to day, cast to DATE for clarity; analytic SUM works the same
<span class="nc" id="L223">            sql = &quot;&quot;&quot;</span>
            WITH events AS (
                SELECT
                    CAST(TRUNC(sh.created_at) AS DATE) AS day_date,
                    sh.item_id                           AS item_id,
                    sh.created_at                        AS created_at,
                    sh.quantity_change                   AS quantity_change,
                    sh.price_at_change                   AS price_at_change,
                    SUM(sh.quantity_change) OVER (
                        PARTITION BY sh.item_id
                        ORDER BY sh.created_at
                    )                                    AS qty_after,
                    ROW_NUMBER() OVER (
                        PARTITION BY TRUNC(sh.created_at), sh.item_id
                        ORDER BY sh.created_at DESC
                    )                                    AS rn
                FROM stock_history sh
                JOIN inventory_item i ON i.id = sh.item_id
                WHERE sh.created_at BETWEEN :start AND :end
                  AND (:supplierId IS NULL OR i.supplier_id = :supplierId)
            )
            SELECT
                e.day_date,
                SUM(
                    COALESCE(e.qty_after, 0) * COALESCE(e.price_at_change, i.price, 0)
                ) AS total_value
            FROM events e
            JOIN inventory_item i ON i.id = e.item_id
            WHERE e.rn = 1
            GROUP BY e.day_date
            ORDER BY e.day_date
        &quot;&quot;&quot;;
        }
        
        final String normalizedSupplier =
<span class="pc bpc" id="L258" title="3 of 4 branches missed.">        (supplierId == null || supplierId.isBlank()) ? null : supplierId.trim();</span>
        
        // Use Timestamps explicitly for both H2 and Oracle drivers
<span class="fc" id="L261">        final java.sql.Timestamp startTs = java.sql.Timestamp.valueOf(start);</span>
<span class="fc" id="L262">        final java.sql.Timestamp endTs   = java.sql.Timestamp.valueOf(end);</span>
        
<span class="fc" id="L264">        final Query nativeQuery = em.createNativeQuery(sql);</span>
<span class="fc" id="L265">        nativeQuery.setParameter(&quot;start&quot;, startTs);</span>
<span class="fc" id="L266">        nativeQuery.setParameter(&quot;end&quot;, endTs);</span>
<span class="fc" id="L267">        nativeQuery.setParameter(&quot;supplierId&quot;, normalizedSupplier);</span>
        
<span class="fc" id="L269">        return nativeQuery.getResultList();</span>
    }
    
    
    /**
    * Current total stock quantity by supplier (simple dashboard pie/bar).
    *
    * &lt;p&gt;&lt;strong&gt;Output row format:&lt;/strong&gt; [supplier_name (String), total_quantity (Number)]&lt;/p&gt;
    */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;Object[]&gt; getTotalStockPerSupplier() {
        final String sql;
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        if (isH2()) {</span>
<span class="fc" id="L283">            sql = &quot;&quot;&quot;</span>
                SELECT s.&quot;NAME&quot; AS supplier_name, SUM(i.&quot;QUANTITY&quot;) AS total_quantity
                FROM &quot;SUPPLIER&quot; s
                JOIN &quot;INVENTORY_ITEM&quot; i ON s.&quot;ID&quot; = i.&quot;SUPPLIER_ID&quot;
                GROUP BY s.&quot;NAME&quot;
                ORDER BY total_quantity DESC
            &quot;&quot;&quot;;
        } else {
<span class="nc" id="L291">            sql = &quot;&quot;&quot;</span>
                SELECT s.name AS supplier_name, SUM(i.quantity) AS total_quantity
            FROM supplier s
            JOIN inventory_item i ON s.id = i.supplier_id
            GROUP BY s.name
            ORDER BY total_quantity DESC
            &quot;&quot;&quot;;
        }
<span class="fc" id="L299">        return em.createNativeQuery(sql).getResultList();</span>
    }
    
    /**
    * Update frequency per item, optionally filtered by supplier.
    *
    * &lt;p&gt;&lt;strong&gt;Output row format:&lt;/strong&gt; [item_name (String), update_count (Number)]&lt;/p&gt;
    *
    * @param supplierId optional supplier ID (case-insensitive for H2 branch)
    */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;Object[]&gt; getUpdateCountPerItemFiltered(String supplierId) {
        final String sql;
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (isH2()) {</span>
<span class="fc" id="L314">            sql = &quot;&quot;&quot;</span>
                SELECT i.&quot;NAME&quot; AS item_name, COUNT(sh.&quot;ID&quot;) AS update_count
                FROM &quot;INVENTORY_ITEM&quot; i
                JOIN &quot;STOCK_HISTORY&quot; sh ON sh.&quot;ITEM_ID&quot; = i.&quot;ID&quot;
                WHERE (:supplierId IS NULL OR UPPER(i.&quot;SUPPLIER_ID&quot;) = UPPER(:supplierId))
                GROUP BY i.&quot;NAME&quot;
                ORDER BY update_count DESC
            &quot;&quot;&quot;;
        } else {
<span class="nc" id="L323">            sql = &quot;&quot;&quot;</span>
                SELECT i.name AS item_name, COUNT(sh.id) AS update_count
            FROM stock_history sh
            JOIN inventory_item i ON sh.item_id = i.id
            WHERE (:supplierId IS NULL OR UPPER(i.supplier_id) = UPPER(:supplierId))
            GROUP BY i.name
            ORDER BY update_count DESC
            &quot;&quot;&quot;;
        }
<span class="pc bpc" id="L332" title="2 of 4 branches missed.">        final String normalizedSupplier = (supplierId == null || supplierId.isBlank()) ? null : supplierId;</span>
<span class="fc" id="L333">        final Query nativeQuery = em.createNativeQuery(sql);</span>
<span class="fc" id="L334">        nativeQuery.setParameter(&quot;supplierId&quot;, normalizedSupplier);</span>
<span class="fc" id="L335">        return nativeQuery.getResultList();</span>
    }
    
    /**
    * Items currently below their minimum threshold, optionally filtered by supplier.
    *
    * &lt;p&gt;&lt;strong&gt;Output row format:&lt;/strong&gt; [name (String), quantity (Number), minimum_quantity (Number)]&lt;/p&gt;
    *
    * @param supplierId optional supplier ID (case-insensitive for H2 branch)
    */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;Object[]&gt; findItemsBelowMinimumStockFiltered(String supplierId) {
        final String sql;
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        if (isH2()) {</span>
<span class="fc" id="L350">            sql = &quot;&quot;&quot;</span>
                SELECT i.&quot;NAME&quot;, i.&quot;QUANTITY&quot;, i.&quot;MINIMUM_QUANTITY&quot;
                FROM &quot;INVENTORY_ITEM&quot; i
                WHERE i.&quot;QUANTITY&quot; &lt; i.&quot;MINIMUM_QUANTITY&quot;
                  AND (:supplierId IS NULL OR UPPER(i.&quot;SUPPLIER_ID&quot;) = UPPER(:supplierId))
                ORDER BY i.&quot;QUANTITY&quot; ASC
            &quot;&quot;&quot;;
        } else {
<span class="nc" id="L358">            sql = &quot;&quot;&quot;</span>
                SELECT i.name, i.quantity, i.minimum_quantity
            FROM inventory_item i
            WHERE i.quantity &lt; i.minimum_quantity
              AND (:supplierId IS NULL OR UPPER(i.supplier_id) = UPPER(:supplierId))
            ORDER BY i.quantity ASC
            &quot;&quot;&quot;;
        }
<span class="pc bpc" id="L366" title="2 of 4 branches missed.">        final String normalizedSupplier = (supplierId == null || supplierId.isBlank()) ? null : supplierId;</span>
<span class="fc" id="L367">        final Query nativeQuery = em.createNativeQuery(sql);</span>
<span class="fc" id="L368">        nativeQuery.setParameter(&quot;supplierId&quot;, normalizedSupplier);</span>
<span class="fc" id="L369">        return nativeQuery.getResultList();</span>
    }
    
    /**
    * Flexible stock update search with time/supplier/item/user/quantity filters.
    *
    * &lt;p&gt;&lt;strong&gt;Output row format:&lt;/strong&gt;
    * [item_name (String), supplier_name (String), quantity_change (Number),
    *  reason (String or enum name), created_by (String), created_at (TIMESTAMP)]&lt;/p&gt;
    */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;Object[]&gt; findFilteredStockUpdates(
    LocalDateTime startDate,
    LocalDateTime endDate,
    String itemName,
    String supplierId,
    String createdBy,
    Integer minChange,
    Integer maxChange
    ) {
        final String sql;
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (isH2()) {</span>
<span class="fc" id="L392">            sql = &quot;&quot;&quot;</span>
                SELECT i.name AS item_name, s.name AS supplier_name, sh.quantity_change, sh.reason, sh.created_by, sh.created_at
                FROM stock_history sh
                JOIN inventory_item i ON sh.item_id = i.id
                JOIN supplier s ON i.supplier_id = s.id
                WHERE (:startDate     IS NULL OR sh.created_at &gt;= :startDate)
                  AND (:endDate       IS NULL OR sh.created_at &lt;= :endDate)
                  AND (:itemPattern   IS NULL OR LOWER(i.name) LIKE :itemPattern)
                  AND (:supplierId    IS NULL OR UPPER(i.supplier_id) = UPPER(:supplierId))
                  AND (:createdByNorm IS NULL OR LOWER(sh.created_by) = :createdByNorm)
                  AND (:minChange     IS NULL OR sh.quantity_change &gt;= :minChange)
                  AND (:maxChange     IS NULL OR sh.quantity_change &lt;= :maxChange)
                ORDER BY sh.created_at DESC
            &quot;&quot;&quot;;
        } else {
<span class="nc" id="L407">            sql = &quot;&quot;&quot;</span>
                SELECT i.name AS item_name, s.name AS supplier_name, sh.quantity_change, sh.reason, sh.created_by, sh.created_at
                FROM stock_history sh
                JOIN inventory_item i ON sh.item_id = i.id
                JOIN supplier s ON i.supplier_id = s.id
                WHERE (:startDate     IS NULL OR sh.created_at &gt;= :startDate)
                  AND (:endDate       IS NULL OR sh.created_at &lt;= :endDate)
                  AND (:itemPattern   IS NULL OR LOWER(i.name) LIKE :itemPattern)
                  AND (:supplierId    IS NULL OR i.supplier_id = :supplierId)
                  AND (:createdByNorm IS NULL OR LOWER(sh.created_by) = :createdByNorm)
                  AND (:minChange     IS NULL OR sh.quantity_change &gt;= :minChange)
                  AND (:maxChange     IS NULL OR sh.quantity_change &lt;= :maxChange)
                ORDER BY sh.created_at DESC
            &quot;&quot;&quot;;
        }
<span class="pc bpc" id="L422" title="2 of 4 branches missed.">        final String itemPattern     = (itemName == null || itemName.isBlank()) ? null : &quot;%&quot; + itemName.toLowerCase() + &quot;%&quot;;</span>
<span class="pc bpc" id="L423" title="2 of 4 branches missed.">        final String normalizedSupp  = (supplierId == null || supplierId.isBlank()) ? null : supplierId;</span>
<span class="pc bpc" id="L424" title="2 of 4 branches missed.">        final String createdByNorm   = (createdBy == null || createdBy.isBlank()) ? null : createdBy.toLowerCase();</span>
        
<span class="fc" id="L426">        final Query q = em.createNativeQuery(sql);</span>
<span class="fc" id="L427">        q.setParameter(&quot;startDate&quot;, startDate);</span>
<span class="fc" id="L428">        q.setParameter(&quot;endDate&quot;, endDate);</span>
<span class="fc" id="L429">        q.setParameter(&quot;itemPattern&quot;, itemPattern);</span>
<span class="fc" id="L430">        q.setParameter(&quot;supplierId&quot;, normalizedSupp);</span>
<span class="fc" id="L431">        q.setParameter(&quot;createdByNorm&quot;, createdByNorm);</span>
<span class="fc" id="L432">        q.setParameter(&quot;minChange&quot;, minChange);</span>
<span class="fc" id="L433">        q.setParameter(&quot;maxChange&quot;, maxChange);</span>
        
<span class="fc" id="L435">        return q.getResultList();</span>
    }
    
    /**
    * Average price trend per day for a specific item (optional supplier filter).
    *
    * &lt;p&gt;&lt;strong&gt;Output row format:&lt;/strong&gt; [day_str (String YYYY-MM-DD), price (BigDecimal)]&lt;/p&gt;
    *
    * @param itemId     required item ID
    * @param supplierId optional supplier ID (null/blank = all)
    * @param start      inclusive lower bound (created_at)
    * @param end        inclusive upper bound (created_at)
    * @return list of day/price pairs ordered by day ascending
    */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public List&lt;PriceTrendDTO&gt; getPriceTrend(String itemId, String supplierId, LocalDateTime start, LocalDateTime end) {
        final String sql;
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">        if (isH2()) {</span>
<span class="fc" id="L454">            sql = &quot;&quot;&quot;</span>
                SELECT CONCAT(
                           CAST(YEAR(sh.created_at) AS VARCHAR), '-',
                           LPAD(CAST(MONTH(sh.created_at) AS VARCHAR), 2, '0'), '-',
                           LPAD(CAST(DAY(sh.created_at) AS VARCHAR), 2, '0')
                       ) AS day_str,
                       AVG(sh.price_at_change) AS price
                FROM stock_history sh
                JOIN inventory_item i ON sh.item_id = i.id
                WHERE sh.created_at BETWEEN :start AND :end
                  AND sh.item_id = :itemId
                  AND (:supplierId IS NULL OR UPPER(i.supplier_id) = UPPER(:supplierId))
                GROUP BY CONCAT(
                           CAST(YEAR(sh.created_at) AS VARCHAR), '-',
                           LPAD(CAST(MONTH(sh.created_at) AS VARCHAR), 2, '0'), '-',
                           LPAD(CAST(DAY(sh.created_at) AS VARCHAR), 2, '0')
                       )
                ORDER BY 1
            &quot;&quot;&quot;;
        } else {
<span class="nc" id="L474">            sql = &quot;&quot;&quot;</span>
                SELECT TO_CHAR(sh.created_at, 'YYYY-MM-DD') AS day_str,
                       AVG(sh.price_at_change) AS price
                FROM stock_history sh
                JOIN inventory_item i ON sh.item_id = i.id
                WHERE sh.created_at BETWEEN :start AND :end
                  AND sh.item_id = :itemId
                  AND (:supplierId IS NULL OR i.supplier_id = :supplierId)
                GROUP BY TO_CHAR(sh.created_at, 'YYYY-MM-DD')
                ORDER BY 1
            &quot;&quot;&quot;;
        }
<span class="pc bpc" id="L486" title="2 of 4 branches missed.">        final String normalizedSupplier = (supplierId == null || supplierId.isBlank()) ? null : supplierId;</span>
        
<span class="fc" id="L488">        final Query q = em.createNativeQuery(sql);</span>
<span class="fc" id="L489">        q.setParameter(&quot;start&quot;, start);</span>
<span class="fc" id="L490">        q.setParameter(&quot;end&quot;, end);</span>
<span class="fc" id="L491">        q.setParameter(&quot;itemId&quot;, itemId);</span>
<span class="fc" id="L492">        q.setParameter(&quot;supplierId&quot;, normalizedSupplier);</span>
        
<span class="fc" id="L494">        final List&lt;Object[]&gt; raw = q.getResultList();</span>
<span class="fc" id="L495">        return raw.stream()</span>
<span class="fc" id="L496">        .map(r -&gt; new PriceTrendDTO((String) r[0], (BigDecimal) r[1]))</span>
<span class="fc" id="L497">        .collect(Collectors.toList());</span>
    }
    
    /**
    * Streams events up to the given time (inclusive) using JPQL over entity properties.
    *
    * &lt;p&gt;Used by the WAC (weighted-average-cost) algorithm to:
    * &lt;ul&gt;
    *   &lt;li&gt;replay events before the analysis window to build opening inventory, and&lt;/li&gt;
    *   &lt;li&gt;aggregate purchases/COGS/write-offs/returns within the window.&lt;/li&gt;
    * &lt;/ul&gt;
    *
    * @param end        inclusive upper bound (compared to entity property {@code createdAt})
    * @param supplierId optional supplier filter (null = all)
    * @return ordered rows projected into {@link StockEventRowDTO}
    */
    @Override
    public List&lt;StockEventRowDTO&gt; findEventsUpTo(LocalDateTime end, String supplierId) {
<span class="fc" id="L515">        final String jpql = &quot;&quot;&quot;</span>
            select new com.smartsupplypro.inventory.dto.StockEventRowDTO(
                sh.itemId, 
                coalesce(sh.supplierId, i.supplierId), 
                sh.timestamp, 
                sh.change,
                sh.priceAtChange,
                sh.reason
            )
            from StockHistory sh, InventoryItem i
            where i.id = sh.itemId 
                and sh.timestamp &lt;= :end
                and (
                    :supplierIdNorm is null 
                    or lower(sh.supplierId) = :supplierIdNorm
                )
            order by sh.itemId asc, sh.timestamp asc
        &quot;&quot;&quot;;

        final String supplierIdNorm = 
<span class="pc bpc" id="L535" title="2 of 4 branches missed.">            (supplierId == null || supplierId.isBlank()) ? null : supplierId.trim().toLowerCase();</span>

<span class="fc" id="L537">        return em.createQuery(jpql, StockEventRowDTO.class)</span>
<span class="fc" id="L538">                .setParameter(&quot;end&quot;, end)</span>
<span class="fc" id="L539">                .setParameter(&quot;supplierIdNorm&quot;, supplierIdNorm)</span>
<span class="fc" id="L540">                .getResultList();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>