#+#+#+#+---------------------------------------------------------------------
# Smart Supply Pro – Frontend (React + Vite + Nginx) Production Deployment
#
# PIPELINE ROLE: Continuous deployment (CD) to Koyeb for the frontend service.
#
# PURPOSE:
# - Trigger automatically after the frontend CI workflow succeeds on main
# - Or allow a manual deployment run via workflow_dispatch
# - Deploy a deterministic container image reference pinned by digest
# - Enforce a health gate via the platform’s authoritative status
# - Perform a lightweight public URL smoke test after HEALTHY
#
# TRIGGERS:
# - workflow_run: on successful completion of "4️⃣ Frontend CI - Build & Test" on main
# - workflow_dispatch: manual run (useful for redeploy / incident response)
#
# DESIGN PRINCIPLES:
# - Immutable deployments: Deploy by image digest (sha256) rather than mutable tags
# - Eventual consistency aware: Docker Hub manifest lookup includes retries
# - Least-privilege: Repository contents are read-only; secrets used only where needed
# - Observability-first: Emit grouped diagnostics on health timeouts and failures
#
# TROUBLESHOOTING:
# - If digest resolution fails: Confirm image was pushed for the commit SHA
# - If deploy fails: Verify Koyeb secrets (token/app/service) and registry secret exists
# - If health gate times out: Inspect Koyeb deployments/instances and backend reachability
# - If smoke test fails but HEALTHY: Suspect CDN/edge routing, SPA base path, or CORS
#+#+#+#+---------------------------------------------------------------------

name: 5️⃣ Deploy Frontend to production (Koyeb)

on:
  workflow_run:
    workflows: ["4️⃣ Frontend CI - Build & Test"]
    types: [completed]
    branches:
      - main
  workflow_dispatch: {}

permissions:
  contents: read

jobs:
  deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    env:
      IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/ssp-frontend
      KOYEB_APP: ${{ secrets.KOYEB_APP }}
      KOYEB_SERVICE: ${{ secrets.KOYEB_SERVICE }}
      FRONTEND_URL: https://inventory-service.koyeb.app

    steps:
      # ----------------------------------------------------------------------
      # 1) Source checkout
      # ----------------------------------------------------------------------
      - name: Checkout
        uses: actions/checkout@v4

      # ----------------------------------------------------------------------
      # 2) Resolve immutable image reference (tag -> digest)
      #
      # Why:
      # - CI produces images tagged by commit SHA.
      # - Deploying by digest ensures deterministic rollouts and safe rollback.
      # - Docker Hub can be eventually consistent; retries reduce flakiness.
      #
      # Notes:
      # - Works for both workflow_run (head_sha) and workflow_dispatch (github.sha).
      # - Uses anonymous pull token for public registry manifest reads.
      # ----------------------------------------------------------------------
      - name: Resolve image reference (tag -> digest)
        id: img
        run: |
          set -euo pipefail

          # Works for workflow_run and workflow_dispatch 
          SHA="${{ github.event.workflow_run.head_sha || github.sha }}"
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"
          
          NAMESPACE="${{ secrets.DOCKER_USERNAME }}"
          REPO="ssp-frontend"
          TAG="$SHA"

          echo "Resolving digest for docker.io/${NAMESPACE}/${REPO}:${TAG} ..."

          # 1) Get an anonymous registry token for this repository (public pull scope)
          TOKEN="$(
            curl -fsSL --retry 5 --retry-connrefused --retry-delay 2 \
              "https://auth.docker.io/token?service=registry.docker.io&scope=repository:${NAMESPACE}/${REPO}:pull" \
            | grep -oE '"token"\s*:\s*"[^"]+"' \
            | sed -E 's/.*"token"\s*:\s*"([^"]+)".*/\1/'
          )"

          if [ -z "${TOKEN:-}" ]; then
            echo "❌ Could not obtain Docker Hub registry token"
            exit 1
          fi

          # 2) Ask registry for the manifest headers and read Docker-Content-Digest
          MANIFEST_URL="https://registry-1.docker.io/v2/${NAMESPACE}/${REPO}/manifests/${TAG}"

          HDRS="$(mktemp)"

          # Retry loop because Docker Hub can be eventually-consistent right after push
          for attempt in 1 2 3 4 5 6 7 8 9 10 11 12; do
            echo "Manifest check attempt $attempt/12 ..."

            STATUS="$(
              curl -sS \
                -D "$HDRS" -o /dev/null -w '%{http_code}' \
                -H "Authorization: Bearer $TOKEN" \
                -H "Accept: application/vnd.docker.distribution.manifest.v2+json, application/vnd.docker.distribution.manifest.list.v2+json, application/vnd.oci.image.index.v1+json" \
                "$MANIFEST_URL" || true
            )"

            echo "Docker Hub manifest HTTP status: $STATUS"

            if [ "$STATUS" = "200" ]; then
              break
            fi

            # Print a few headers for diagnosis
            echo "::group::Docker Hub headers (first 40 lines)"
            sed -n '1,40p' "$HDRS" || true
            echo "::endgroup::"

            sleep 10
          done

          if [ "$STATUS" != "200" ]; then
            echo "❌ Manifest request never returned 200. Final HTTP status: $STATUS"
            exit 1
          fi

          DIGEST="$(
            tr -d '\r' < "$HDRS" \
            | awk -F': ' 'tolower($1)=="docker-content-digest" {print $2}' \
            | tail -n1
          )"

          if [ -z "${DIGEST:-}" ]; then
            echo "❌ Manifest returned 200 but no Docker-Content-Digest header was found."
            echo "::group::Docker Hub headers (first 80 lines)"
            sed -n '1,80p' "$HDRS" || true
            echo "::endgroup::"
            exit 1
          fi  

          IMAGE_REF="docker.io/${NAMESPACE}/${REPO}@${DIGEST}"
          echo "✅ Resolved: ${IMAGE_REF}"
          echo "image_ref=${IMAGE_REF}" >> "$GITHUB_OUTPUT"

          # (Optional) Validate image exists, similar to backend 3-deploy-fly.yml

      # ----------------------------------------------------------------------
      # 3) Install Koyeb CLI (latest, with retry)
      #
      # Why:
      # - Use the platform CLI as the source of truth for service status.
      # - Install latest by default; keep a fallback pin to avoid breakage.
      # ----------------------------------------------------------------------
      - name: Install Koyeb CLI
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.koyeb/bin"
          # Discover latest version (no jq). If discovery fails, fall back to a known version.
          VER="$(curl -fsSL --retry 5 --retry-connrefused --retry-delay 2 \
                https://api.github.com/repos/koyeb/koyeb-cli/releases/latest \
                | grep -oE '"tag_name":\s*"v[0-9.]+"' | head -n1 \
                | sed -E 's/.*"v([^"]+)".*/\1/')" || VER=""
          if [ -z "$VER" ]; then
            VER="4.4.1"  # fallback pin; update when needed
          fi
          TARBALL="koyeb-cli_${VER}_linux_amd64.tar.gz"
          URL="https://github.com/koyeb/koyeb-cli/releases/download/v${VER}/${TARBALL}"
          echo "Installing Koyeb CLI v${VER} from ${URL}"
          curl -fsSL --retry 5 --retry-connrefused --retry-delay 2 -o /tmp/koyeb.tgz "$URL"
          tar -xzf /tmp/koyeb.tgz -C "$HOME/.koyeb/bin"
          rm /tmp/koyeb.tgz
          echo "$HOME/.koyeb/bin" >> "$GITHUB_PATH"

      # Basic diagnostic: confirms CLI is available on PATH.
      - name: Koyeb CLI version
        run: koyeb version

      # ----------------------------------------------------------------------
      # 4) Authenticate Koyeb (non-interactive CI)
      #
      # Security notes:
      # - Avoid echoing secrets; write token to file with restrictive perms.
      # - Keep token scope minimal and rotate regularly.
      # ----------------------------------------------------------------------
      - name: Authenticate Koyeb (CI mode)
        env:
          KOYEB_TOKEN: ${{ secrets.KOYEB_TOKEN }}
        run: |
          set -euo pipefail
          umask 077
          mkdir -p "$HOME"
          printf "token: %s\n" "$KOYEB_TOKEN" > "$HOME/.koyeb.yaml"
          chmod 600 "$HOME/.koyeb.yaml"

      # ----------------------------------------------------------------------
      # 5) Validate the resolved image reference is well-formed
      #
      # Why:
      # - Fail fast on malformed output before calling the deployment API.
      # ----------------------------------------------------------------------
      - name: Validate image ref
        run: |
          set -euo pipefail
          REF="${{ steps.img.outputs.image_ref }}"
          echo "Image ref: $REF"

          # Accept either:
          #  - docker.io/user/repo:tag
          #  - docker.io/user/repo@sha256:digest
          if [[ "$REF" =~ ^docker\.io\/[^\/]+\/[^:]+:[A-Za-z0-9._-]+$ ]]; then
            echo "✅ Tag reference looks valid"
            exit 0
          fi
          if [[ "$REF" =~ ^docker\.io\/[^\/]+\/[^@]+@sha256:[a-f0-9]{64}$ ]]; then
            echo "✅ Digest reference looks valid"
            exit 0
          fi
          echo "❌ Invalid docker image reference: $REF"
          exit 1

      # ----------------------------------------------------------------------
      # 6) Deploy to Koyeb (pin by digest + keep ports pinned)
      #
      # Why:
      # - Digest pinning: deterministic rollouts and rollbacks.
      # - Passing --ports every time prevents accidental config drift.
      # - Retries: Koyeb <-> registry connectivity can be flaky.
      # ----------------------------------------------------------------------
      - name: Deploy to Koyeb (pin by digest + keep ports)
        run: |
          set -euo pipefail
          SVC="${{ env.KOYEB_APP }}/${{ env.KOYEB_SERVICE }}"
          REF="${{ steps.img.outputs.image_ref }}"
          echo "Updating $SVC to $REF ..."

          # Retry because Koyeb<->registry connectivity can be flaky
          for attempt in 1 2 3 4 5; do
            echo "Deploy attempt $attempt/5"
            if koyeb service update "$SVC" \
              --docker "$REF" \
              --ports 8080:http \
              --docker-private-registry-secret docker-hub-registry; then
              echo "✅ Deploy command accepted"
              exit 0
            fi
            echo "❌ Deploy failed; sleeping before retry..."
            sleep $((attempt * 10))
          done

          echo "❌ All deploy attempts failed"
          exit 1   

      # ----------------------------------------------------------------------
      # 7) Post-deploy health gate (authoritative platform status)
      #
      # Why:
      # - Prefer platform status over public curl to avoid transient edge noise.
      # - On timeout, emit Koyeb diagnostics to speed up incident triage.
      # ----------------------------------------------------------------------
      - name: Wait for Koyeb service to be HEALTHY
        run: |
          set -euo pipefail
          SVC="${{ env.KOYEB_APP }}/${{ env.KOYEB_SERVICE }}"
          echo "Waiting for $SVC to be HEALTHY..."
          for i in $(seq 1 60); do  # ~5 minutes
            if koyeb service describe "$SVC" 2>/dev/null \
              | tr '[:upper:]' '[:lower:]' | grep -q 'healthy'; then
              echo "Service reports HEALTHY."
              exit 0
            fi
            echo "Not healthy yet... ($i/60)"
            sleep 5
          done
          echo "::group::Koyeb diagnostics"
          koyeb service describe "$SVC" || true
          koyeb service deployments list "$SVC" --limit 5 || true
          koyeb service instances list "$SVC" || true
          echo "::endgroup::"
          exit 1

      # ----------------------------------------------------------------------
      # 8) (Optional) Public URL smoke test
      #
      # Why:
      # - After HEALTHY, verify the public endpoint returns 200.
      # - Catches CDN/edge/routing issues independent of container health.
      # ----------------------------------------------------------------------
      - name: Smoke test public URL
        if: ${{ success() }}
        env:
          URL: ${{ env.FRONTEND_URL }}
        run: |
          set -euo pipefail
          # brief settle before probing the edge
          sleep 5
          for i in $(seq 1 60); do
            CODE="$(curl -sS -L -o /dev/null -w '%{http_code}' "$URL")"
            echo "Attempt $i: HTTP $CODE"
            if [ "$CODE" = "200" ]; then
              echo "Public URL ready."
              exit 0
            fi
            sleep 5
          done
          echo "::group::curl diagnostics"
          curl -I -L "$URL" || true
          curl -s -L "$URL" | head -n 60 || true
          echo "::endgroup::"
          exit 1

